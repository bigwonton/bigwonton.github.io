{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/avatar.jpeg","path":"avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1544872648196},{"_id":"themes/yilia/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1544869676192},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1544869549868},{"_id":"themes/yilia/_config.yml","hash":"905001b66b53234f8ee35b253a2f397bc6b95014","modified":1544874647754},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1544869549878},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1544869549900},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1566133057076},{"_id":"source/_posts/2019计划.md","hash":"8ccf25968e1f890f76fbb45fabdba990922ae5f7","modified":1566131912427},{"_id":"source/_posts/react-native-run-ios-踩坑记录.md","hash":"e0c5bf4d7fc69bf8c7981e436a3e463466e3778e","modified":1566494843828},{"_id":"source/_posts/ES6-Notes.md","hash":"eec2dd5691c78e8cb45ef58df7cc28ce684c7856","modified":1565791095428},{"_id":"source/_posts/hexo-github搭建博客.md","hash":"cb9ddc151cb849ca2f3d4a94f6a3388a6f19d9a3","modified":1566132827178},{"_id":"source/_posts/AWS-shadowsocks.md","hash":"bcbb8323f6735ded67845bceffc0e118f6e310c1","modified":1566132447232},{"_id":"source/_posts/刷题记 leetcode 42 Trapping Rain Water.md","hash":"ca0a29003a9ec671a3e13e69ca6109c1e2d52d8f","modified":1566132254493},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1544869549868},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1544869549869},{"_id":"source/_posts/《SQL学习指南》笔记.md","hash":"e2326741744ef3994c40ecebed62376ee0d43196","modified":1544873433620},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1544869549869},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1544869549869},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1544869549869},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1544869549869},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1544869549869},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1544869549876},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1544869549877},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1544869549876},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1544869549877},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1544869549877},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1544869549878},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1544869549878},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1544869549877},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1544869549894},{"_id":"themes/yilia/source/avatar.jpeg","hash":"e604ea3efdcd5c82a6ec7eeee28759ce4bca035c","modified":1544865162396},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1544869549898},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1544869549900},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1544869549876},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1544869549899},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1544869549899},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1544869549870},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1544869549870},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1544869549870},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1544869549870},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1544869549871},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1544869549870},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1544869549871},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1544869549871},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1544869549871},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1544869549871},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1544869549871},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1544869549872},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1544869549872},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1544869549872},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1544869549876},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1544869549876},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1544869549878},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1544869549879},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1544869549879},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1544869549879},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1544869549879},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1544869549879},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1544869549880},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"331b171d67293a27920a6128978b2611227813db","modified":1544874338999},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1544869549880},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1544869549882},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1544869549884},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1544869549884},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1544869549885},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1544869549885},{"_id":"themes/yilia/source-src/css/left.scss","hash":"136081c232b90069f69518c6fdf1ef1db52eabc0","modified":1544874342731},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1544869549886},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1544869549887},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1544869549887},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1544869549887},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1544869549887},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1544869549888},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1544869549888},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1544869549888},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1544869549889},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1544869549889},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1544869549889},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1544869549889},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1544869549890},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1544869549890},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1544869549891},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1544869549890},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1544869549891},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1544869549892},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1544869549891},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1544869549892},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1544869549892},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1544869549893},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1544869549893},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1544869549894},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1544869549893},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1544869549895},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1544869549895},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1544869549895},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1544869549896},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1544869549896},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1544869549897},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1544869549897},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1544869549898},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1544869549875},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1544869549872},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1544869549873},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1544869549873},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1544869549873},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1544869549873},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1544869549873},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1544869549874},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1544869549874},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1544869549873},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1544869549874},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1544869549880},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1544869549881},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1544869549882},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1544869549881},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1544869549881},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1544869549882},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1544869549883},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1544869549883},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1544869549884},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1544869549886},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1544869549885},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1544869549885},{"_id":"public/content.json","hash":"a508e10e1509670f43128f2f62028d022c408cc6","modified":1566631993701},{"_id":"public/2019/08/18/2019计划/index.html","hash":"25a000957e510354b10ef6aeb9304612d8726a6c","modified":1566631994107},{"_id":"public/2019/08/14/hexo-github搭建博客/index.html","hash":"8203162ae01a03fb26acc9225eec13741638de72","modified":1566631994107},{"_id":"public/2019/08/14/ES6-Notes/index.html","hash":"0bb1aec3b2c86ba7ca584e2752414130a7b56165","modified":1566631994124},{"_id":"public/2019/02/12/刷题记 leetcode 42 Trapping Rain Water/index.html","hash":"d8a3554d67e8f5aeb23d8048229418337b1b3e8c","modified":1566631994124},{"_id":"public/2018/12/15/AWS-shadowsocks/index.html","hash":"b25aab3aa2ac5edb6047cc81e12638ecb1bc2583","modified":1566631994125},{"_id":"public/2018/12/15/《SQL学习指南》笔记/index.html","hash":"4a48627fdc4601297041274c56c85be7113c4e7a","modified":1566631994125},{"_id":"public/archives/index.html","hash":"8a48468913cc4d397d66d087648183a68dbdc1ba","modified":1566631994126},{"_id":"public/archives/2018/index.html","hash":"46505f52484b6779b026ca38535d0596f8e35bf9","modified":1566631994126},{"_id":"public/archives/2018/12/index.html","hash":"46f0949dc15e1423b20be746c4e401bb6370c23a","modified":1566631994126},{"_id":"public/archives/2019/index.html","hash":"391aa65436f2c3e3e5ae6d082cab1cdfb49df403","modified":1566631994126},{"_id":"public/archives/2019/02/index.html","hash":"3dfa45c1b802be66f5231bc5bd949d053055f4b5","modified":1566631994126},{"_id":"public/archives/2019/08/index.html","hash":"09235d1cdeaaf670599e5b319bc725eebd39b5d1","modified":1566631994126},{"_id":"public/tags/计划/index.html","hash":"43ae6d908e63b3fe23077f652197f40c80f0328e","modified":1566631994126},{"_id":"public/tags/工具/index.html","hash":"4abb7c9c7e4d1bf042029a5f57461ae78d255eb5","modified":1566631994127},{"_id":"public/tags/leetcode/index.html","hash":"da2a4b3fa431a591a960da935206874400fd769a","modified":1566631994127},{"_id":"public/tags/算法/index.html","hash":"e6ba298d50e3451d9ef471848f0ed6380b2d394d","modified":1566631994127},{"_id":"public/tags/SQL/index.html","hash":"ef1aea91d70cd2bc023d414ebd29775a3be5f2c1","modified":1566631994127},{"_id":"public/index.html","hash":"ce60bca855ddae3219c5e4ef21961dfc0e56218b","modified":1566631994127},{"_id":"public/2019/08/23/react-native-run-ios-踩坑记录/index.html","hash":"1fe9de9b7a959363295dba901833fa677e9d0102","modified":1566631994130},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1566631994133},{"_id":"public/avatar.jpeg","hash":"e604ea3efdcd5c82a6ec7eeee28759ce4bca035c","modified":1566631994133},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1566631994133},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1566631994133},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1566631994133},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1566631994133},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1566631994133},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1566631994134},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1566631994134},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1566631994134},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1566631994151},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1566631994152},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1566631994152},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1566631994155}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"2019计划","date":"2019-08-18T11:37:39.000Z","_content":"\n## 前言\n\n时间真的过的特别快，2019年转眼过去了8个多月了。简单回顾一下，3月份打算换份工作，4月中旬离职，休息了一个月，中间还去云南玩了一圈，5月中旬入职，算一算入职到现在已经3个月了。这三个月，感觉自己成长并不大，跟自己不愿花时间和效率低有很大关系，上班接触的技术是比较陈旧和落后，但我自己也不能因此而懈怠。下班后除了看电视，啥也不干，觉也不好好睡，感到很惭愧。于是最近有个想法，就是给自己每个月都制定一个计划，为了督促自己，决定将计划写在博客上。\n\n## 计划\n\n### React 技术栈\n\n- **目标**\n    \n> 目标：完成一个React Native + Redux的App。\n时间：8.18-9.30\n成果：demo+说明文档\n\n\n- **目标拆分**\n\n> 考虑到自己的基础比较薄弱，薄弱到什么程度呢，就是ES6都没有学完，决定将一部分时间拿来打基础。\n1. 完成《ES6标准入门》阮一峰     8.18-8.24\n2. 通读 React 官方文档 https://react.docschina.org/docs/getting-started.html      8.25-8.26\n3. 通读 React Native 官方文档 https://facebook.github.io/react-native/  中文版（非官方） https://reactnative.cn/   8.27-8.28\n4. 开发 App，开发时记录过程   8.28-9.30\n5. 完成极客时间的《重学前端》专栏课程的学习  8.19-9.30\n\n### Spring 技术栈\n\n- **目标**\n\n> 粗读《Spring实战（第四版）》 粗读《Spring技术内幕》\n时间：8.18-9.30\n成果：笔记\n\n-- **目标拆分**\n\n> 这本书其实之前翻过一点点，但是自己没有练习，没有笔记，所以应该也没有啥印象了，决定重新读一下，做一些笔记（最好加入自己的思考，不是一味抄书），让自己有个更清楚的认识。\n1. 粗读《Spring实战（第四版）》 8.18-9.10\n2. 粗读《深入分析Java Web技术内幕》9.11-9.30","source":"_posts/2019计划.md","raw":"---\ntitle: 2019计划\ndate: 2019-08-18 19:37:39\ntags: 计划\n---\n\n## 前言\n\n时间真的过的特别快，2019年转眼过去了8个多月了。简单回顾一下，3月份打算换份工作，4月中旬离职，休息了一个月，中间还去云南玩了一圈，5月中旬入职，算一算入职到现在已经3个月了。这三个月，感觉自己成长并不大，跟自己不愿花时间和效率低有很大关系，上班接触的技术是比较陈旧和落后，但我自己也不能因此而懈怠。下班后除了看电视，啥也不干，觉也不好好睡，感到很惭愧。于是最近有个想法，就是给自己每个月都制定一个计划，为了督促自己，决定将计划写在博客上。\n\n## 计划\n\n### React 技术栈\n\n- **目标**\n    \n> 目标：完成一个React Native + Redux的App。\n时间：8.18-9.30\n成果：demo+说明文档\n\n\n- **目标拆分**\n\n> 考虑到自己的基础比较薄弱，薄弱到什么程度呢，就是ES6都没有学完，决定将一部分时间拿来打基础。\n1. 完成《ES6标准入门》阮一峰     8.18-8.24\n2. 通读 React 官方文档 https://react.docschina.org/docs/getting-started.html      8.25-8.26\n3. 通读 React Native 官方文档 https://facebook.github.io/react-native/  中文版（非官方） https://reactnative.cn/   8.27-8.28\n4. 开发 App，开发时记录过程   8.28-9.30\n5. 完成极客时间的《重学前端》专栏课程的学习  8.19-9.30\n\n### Spring 技术栈\n\n- **目标**\n\n> 粗读《Spring实战（第四版）》 粗读《Spring技术内幕》\n时间：8.18-9.30\n成果：笔记\n\n-- **目标拆分**\n\n> 这本书其实之前翻过一点点，但是自己没有练习，没有笔记，所以应该也没有啥印象了，决定重新读一下，做一些笔记（最好加入自己的思考，不是一味抄书），让自己有个更清楚的认识。\n1. 粗读《Spring实战（第四版）》 8.18-9.10\n2. 粗读《深入分析Java Web技术内幕》9.11-9.30","slug":"2019计划","published":1,"updated":"2019-08-18T12:38:32.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzp88m9z00007n8u3wy75q8i","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>时间真的过的特别快，2019年转眼过去了8个多月了。简单回顾一下，3月份打算换份工作，4月中旬离职，休息了一个月，中间还去云南玩了一圈，5月中旬入职，算一算入职到现在已经3个月了。这三个月，感觉自己成长并不大，跟自己不愿花时间和效率低有很大关系，上班接触的技术是比较陈旧和落后，但我自己也不能因此而懈怠。下班后除了看电视，啥也不干，觉也不好好睡，感到很惭愧。于是最近有个想法，就是给自己每个月都制定一个计划，为了督促自己，决定将计划写在博客上。</p>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><h3 id=\"React-技术栈\"><a href=\"#React-技术栈\" class=\"headerlink\" title=\"React 技术栈\"></a>React 技术栈</h3><ul>\n<li><strong>目标</strong></li>\n</ul>\n<blockquote>\n<p>目标：完成一个React Native + Redux的App。<br>时间：8.18-9.30<br>成果：demo+说明文档</p>\n</blockquote>\n<ul>\n<li><strong>目标拆分</strong></li>\n</ul>\n<blockquote>\n<p>考虑到自己的基础比较薄弱，薄弱到什么程度呢，就是ES6都没有学完，决定将一部分时间拿来打基础。</p>\n<ol>\n<li>完成《ES6标准入门》阮一峰     8.18-8.24</li>\n<li>通读 React 官方文档 <a href=\"https://react.docschina.org/docs/getting-started.html\" target=\"_blank\" rel=\"noopener\">https://react.docschina.org/docs/getting-started.html</a>      8.25-8.26</li>\n<li>通读 React Native 官方文档 <a href=\"https://facebook.github.io/react-native/\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/</a>  中文版（非官方） <a href=\"https://reactnative.cn/\" target=\"_blank\" rel=\"noopener\">https://reactnative.cn/</a>   8.27-8.28</li>\n<li>开发 App，开发时记录过程   8.28-9.30</li>\n<li>完成极客时间的《重学前端》专栏课程的学习  8.19-9.30</li>\n</ol>\n</blockquote>\n<h3 id=\"Spring-技术栈\"><a href=\"#Spring-技术栈\" class=\"headerlink\" title=\"Spring 技术栈\"></a>Spring 技术栈</h3><ul>\n<li><strong>目标</strong></li>\n</ul>\n<blockquote>\n<p>粗读《Spring实战（第四版）》 粗读《Spring技术内幕》<br>时间：8.18-9.30<br>成果：笔记</p>\n</blockquote>\n<p>– <strong>目标拆分</strong></p>\n<blockquote>\n<p>这本书其实之前翻过一点点，但是自己没有练习，没有笔记，所以应该也没有啥印象了，决定重新读一下，做一些笔记（最好加入自己的思考，不是一味抄书），让自己有个更清楚的认识。</p>\n<ol>\n<li>粗读《Spring实战（第四版）》 8.18-9.10</li>\n<li>粗读《深入分析Java Web技术内幕》9.11-9.30</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>时间真的过的特别快，2019年转眼过去了8个多月了。简单回顾一下，3月份打算换份工作，4月中旬离职，休息了一个月，中间还去云南玩了一圈，5月中旬入职，算一算入职到现在已经3个月了。这三个月，感觉自己成长并不大，跟自己不愿花时间和效率低有很大关系，上班接触的技术是比较陈旧和落后，但我自己也不能因此而懈怠。下班后除了看电视，啥也不干，觉也不好好睡，感到很惭愧。于是最近有个想法，就是给自己每个月都制定一个计划，为了督促自己，决定将计划写在博客上。</p>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><h3 id=\"React-技术栈\"><a href=\"#React-技术栈\" class=\"headerlink\" title=\"React 技术栈\"></a>React 技术栈</h3><ul>\n<li><strong>目标</strong></li>\n</ul>\n<blockquote>\n<p>目标：完成一个React Native + Redux的App。<br>时间：8.18-9.30<br>成果：demo+说明文档</p>\n</blockquote>\n<ul>\n<li><strong>目标拆分</strong></li>\n</ul>\n<blockquote>\n<p>考虑到自己的基础比较薄弱，薄弱到什么程度呢，就是ES6都没有学完，决定将一部分时间拿来打基础。</p>\n<ol>\n<li>完成《ES6标准入门》阮一峰     8.18-8.24</li>\n<li>通读 React 官方文档 <a href=\"https://react.docschina.org/docs/getting-started.html\" target=\"_blank\" rel=\"noopener\">https://react.docschina.org/docs/getting-started.html</a>      8.25-8.26</li>\n<li>通读 React Native 官方文档 <a href=\"https://facebook.github.io/react-native/\" target=\"_blank\" rel=\"noopener\">https://facebook.github.io/react-native/</a>  中文版（非官方） <a href=\"https://reactnative.cn/\" target=\"_blank\" rel=\"noopener\">https://reactnative.cn/</a>   8.27-8.28</li>\n<li>开发 App，开发时记录过程   8.28-9.30</li>\n<li>完成极客时间的《重学前端》专栏课程的学习  8.19-9.30</li>\n</ol>\n</blockquote>\n<h3 id=\"Spring-技术栈\"><a href=\"#Spring-技术栈\" class=\"headerlink\" title=\"Spring 技术栈\"></a>Spring 技术栈</h3><ul>\n<li><strong>目标</strong></li>\n</ul>\n<blockquote>\n<p>粗读《Spring实战（第四版）》 粗读《Spring技术内幕》<br>时间：8.18-9.30<br>成果：笔记</p>\n</blockquote>\n<p>– <strong>目标拆分</strong></p>\n<blockquote>\n<p>这本书其实之前翻过一点点，但是自己没有练习，没有笔记，所以应该也没有啥印象了，决定重新读一下，做一些笔记（最好加入自己的思考，不是一味抄书），让自己有个更清楚的认识。</p>\n<ol>\n<li>粗读《Spring实战（第四版）》 8.18-9.10</li>\n<li>粗读《深入分析Java Web技术内幕》9.11-9.30</li>\n</ol>\n</blockquote>\n"},{"title":"ES6 Notes","date":"2019-08-14T13:58:15.000Z","_content":"","source":"_posts/ES6-Notes.md","raw":"---\ntitle: ES6 Notes\ndate: 2019-08-14 21:58:15\ntags:\n---\n","slug":"ES6-Notes","published":1,"updated":"2019-08-14T13:58:15.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzp88ma500017n8unypd0qsi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"react-native run-ios 踩坑记录","date":"2019-08-22T17:08:55.000Z","_content":"\n\n> 1. React-Native mac 运行报错 error Failed to build iOS project. We ran \"xcodebuild\" command but it exited with error code 65. \n\n原因：第三方依赖包下载太慢。\n\n解决办法：手动下载。\n\n- 查看第三方依赖包\n\n```\ncat node_modules/react-native/scripts/ios-install-third-party.sh\n```\n\n- 下载\nhttps://github.com/google/glog/archive/v0.3.5.tar.gz\nhttps://github.com/google/double-conversion/archive/v1.1.6.tar.gz\nhttps://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz\nhttps://github.com/facebook/folly/archive/v2018.10.22.00.tar.gz\n\n- 新建文件夹 .rncache，将下载的四个文件移入到目录下\n```\nmkdir ~/.rncache\n```\n\n- 可有可无的一步，手动运行脚本，因为下面run-ios的时候回解压四个压缩包到指定目录，无需手动执行\n```\nnode_modules/react-native/scripts/ios-install-third-party.sh\n```\n\n- 重新安装npm依赖，运行\n\n```\nrm -rf node_modules \nnpm cache clean --force\n\nnpm install \n\nreact-native run-ios\n```\n\n> 2. react native undefined is not an object RNGestureHandlerModule.State\n\n```\nrm -rf node_modules\nrm -rf package_lock.json\nnpm install\nnpm install --save react-navigation               //这两步install可以不做，如果package.json里有的话\nnpm install --save react-native-gesture-handler   //这两步install可以不做，如果package.json里有的话\nreact-native link\n```\n\n\n\n> 3. Error: Unable to resolve module `./DrawerLayout` from `/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js`: The module `./DrawerLayout` could not be found from `/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js`.\n\n\n\n\n","source":"_posts/react-native-run-ios-踩坑记录.md","raw":"---\ntitle: react-native run-ios 踩坑记录\ndate: 2019-08-23 01:08:55\ntags:\n---\n\n\n> 1. React-Native mac 运行报错 error Failed to build iOS project. We ran \"xcodebuild\" command but it exited with error code 65. \n\n原因：第三方依赖包下载太慢。\n\n解决办法：手动下载。\n\n- 查看第三方依赖包\n\n```\ncat node_modules/react-native/scripts/ios-install-third-party.sh\n```\n\n- 下载\nhttps://github.com/google/glog/archive/v0.3.5.tar.gz\nhttps://github.com/google/double-conversion/archive/v1.1.6.tar.gz\nhttps://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz\nhttps://github.com/facebook/folly/archive/v2018.10.22.00.tar.gz\n\n- 新建文件夹 .rncache，将下载的四个文件移入到目录下\n```\nmkdir ~/.rncache\n```\n\n- 可有可无的一步，手动运行脚本，因为下面run-ios的时候回解压四个压缩包到指定目录，无需手动执行\n```\nnode_modules/react-native/scripts/ios-install-third-party.sh\n```\n\n- 重新安装npm依赖，运行\n\n```\nrm -rf node_modules \nnpm cache clean --force\n\nnpm install \n\nreact-native run-ios\n```\n\n> 2. react native undefined is not an object RNGestureHandlerModule.State\n\n```\nrm -rf node_modules\nrm -rf package_lock.json\nnpm install\nnpm install --save react-navigation               //这两步install可以不做，如果package.json里有的话\nnpm install --save react-native-gesture-handler   //这两步install可以不做，如果package.json里有的话\nreact-native link\n```\n\n\n\n> 3. Error: Unable to resolve module `./DrawerLayout` from `/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js`: The module `./DrawerLayout` could not be found from `/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js`.\n\n\n\n\n","slug":"react-native-run-ios-踩坑记录","published":1,"updated":"2019-08-22T17:27:23.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzp88ma900037n8ue69mdm1u","content":"<blockquote>\n<ol>\n<li>React-Native mac 运行报错 error Failed to build iOS project. We ran “xcodebuild” command but it exited with error code 65. </li>\n</ol>\n</blockquote>\n<p>原因：第三方依赖包下载太慢。</p>\n<p>解决办法：手动下载。</p>\n<ul>\n<li>查看第三方依赖包</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat node_modules/react-native/scripts/ios-install-third-party.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>下载<br><a href=\"https://github.com/google/glog/archive/v0.3.5.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/google/glog/archive/v0.3.5.tar.gz</a><br><a href=\"https://github.com/google/double-conversion/archive/v1.1.6.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/google/double-conversion/archive/v1.1.6.tar.gz</a><br><a href=\"https://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz</a><br><a href=\"https://github.com/facebook/folly/archive/v2018.10.22.00.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/facebook/folly/archive/v2018.10.22.00.tar.gz</a></p>\n</li>\n<li><p>新建文件夹 .rncache，将下载的四个文件移入到目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ~/.rncache</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可有可无的一步，手动运行脚本，因为下面run-ios的时候回解压四个压缩包到指定目录，无需手动执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_modules/react-native/scripts/ios-install-third-party.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新安装npm依赖，运行</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node_modules </span><br><span class=\"line\">npm cache clean --force</span><br><span class=\"line\"></span><br><span class=\"line\">npm install </span><br><span class=\"line\"></span><br><span class=\"line\">react-native run-ios</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"2\">\n<li>react native undefined is not an object RNGestureHandlerModule.State</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node_modules</span><br><span class=\"line\">rm -rf package_lock.json</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install --save react-navigation               //这两步install可以不做，如果package.json里有的话</span><br><span class=\"line\">npm install --save react-native-gesture-handler   //这两步install可以不做，如果package.json里有的话</span><br><span class=\"line\">react-native link</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"3\">\n<li>Error: Unable to resolve module <code>./DrawerLayout</code> from <code>/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js</code>: The module <code>./DrawerLayout</code> could not be found from <code>/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js</code>.</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ol>\n<li>React-Native mac 运行报错 error Failed to build iOS project. We ran “xcodebuild” command but it exited with error code 65. </li>\n</ol>\n</blockquote>\n<p>原因：第三方依赖包下载太慢。</p>\n<p>解决办法：手动下载。</p>\n<ul>\n<li>查看第三方依赖包</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat node_modules/react-native/scripts/ios-install-third-party.sh</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>下载<br><a href=\"https://github.com/google/glog/archive/v0.3.5.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/google/glog/archive/v0.3.5.tar.gz</a><br><a href=\"https://github.com/google/double-conversion/archive/v1.1.6.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/google/double-conversion/archive/v1.1.6.tar.gz</a><br><a href=\"https://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/react-native-community/boost-for-react-native/releases/download/v1.63.0-0/boost_1_63_0.tar.gz</a><br><a href=\"https://github.com/facebook/folly/archive/v2018.10.22.00.tar.gz\" target=\"_blank\" rel=\"noopener\">https://github.com/facebook/folly/archive/v2018.10.22.00.tar.gz</a></p>\n</li>\n<li><p>新建文件夹 .rncache，将下载的四个文件移入到目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir ~/.rncache</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可有可无的一步，手动运行脚本，因为下面run-ios的时候回解压四个压缩包到指定目录，无需手动执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node_modules/react-native/scripts/ios-install-third-party.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重新安装npm依赖，运行</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node_modules </span><br><span class=\"line\">npm cache clean --force</span><br><span class=\"line\"></span><br><span class=\"line\">npm install </span><br><span class=\"line\"></span><br><span class=\"line\">react-native run-ios</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"2\">\n<li>react native undefined is not an object RNGestureHandlerModule.State</li>\n</ol>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf node_modules</span><br><span class=\"line\">rm -rf package_lock.json</span><br><span class=\"line\">npm install</span><br><span class=\"line\">npm install --save react-navigation               //这两步install可以不做，如果package.json里有的话</span><br><span class=\"line\">npm install --save react-native-gesture-handler   //这两步install可以不做，如果package.json里有的话</span><br><span class=\"line\">react-native link</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol start=\"3\">\n<li>Error: Unable to resolve module <code>./DrawerLayout</code> from <code>/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js</code>: The module <code>./DrawerLayout</code> could not be found from <code>/Users/xinyingshi/Projects/github-demo/MeiTuan/node_modules/react-navigation-drawer/dist/views/DrawerView.js</code>.</li>\n</ol>\n</blockquote>\n"},{"title":"hexo+github搭建博客","date":"2019-08-14T14:05:15.000Z","toc":true,"_content":"\n## 准备工作\n\n1. github账号\n2. 安装`node.js` 和`npm`\n3. 安装git\n\n## 新建仓库\n\n新建 `bigwonton.github.io`的仓库，以后的访问网站就是`https://bigwonton.github.io`\n\n## 安装hexo\n\n```\nnpm install -g hexo\nnpm install hexo-deploy-git --save //安装插件\n```\n\n<!--more-->\n\n## 初始化\n\n```\nhexo init //初始化\n```\n\n## 配置`_config.yml`\n```\n//下载主题，放在themes文件夹下\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n修改配置文件\n```\n## 换主题\ntheme: yilia \n\ndeploy:\n  type: git\n  repo: git@github.com:bigwonton/bigwonton.github.io.git\n  branch: master\n```\n\n\n## 上传到github\n```\n\nhexo new 'newArticleName' //新建文章\n\nhexo g   // 生成 html\n\nhexo d   // 上传到github\n\n```\n\n## 其他命令\n\n```\nhexo clean // 清理public文件夹下的内容\n\nhexo new page 'newPageName' //新建页面\n\nhexo s   // 开启本地预览服务 localhost:4000\n\n```\n\n## 多终端写博客\n\n\n### 创建hexo分支\n\n\n配置gitignore文件\n\n```\n/.deploy_git\n/public\n```\n初始化仓库及提交\n\n```\ngit init  //初始化本地仓库\ngit remote add origin git@github.com:bigwonton/bigwonton.github.io.git  //添加远程仓库 <server> 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端\ngit add . //添加本地所有文件到仓库        \ngit commit -m \"更新说明\" //添加commit\ngit checkout -b hexo //创建hexo分支\ngit push origin hexo //将本地仓库的源文件推送到远程仓库\n```\n\n### 新终端初始化\n\n```\ngit clone git@github.com:bigwonton/bigwonton.github.io.git  //克隆hexo分支\nnpm install \n```\n\n\n### 写博客提交方法\n\n```\ngit checkout hexo //切换hexo分支\n\ngit pull //每次写博客之前，先拉取hexo分支最新代码\n```\n\n编辑md文件，提交\n\n```\ngit commit -m \"添加新博客\"\ngit push origin hexo\nhexo g -d //部署\n```\n\n\n\n\n\n","source":"_posts/hexo-github搭建博客.md","raw":"---\ntitle: hexo+github搭建博客\ndate: 2019-08-14 22:05:15\ntags: \n- 工具\ntoc: true\n---\n\n## 准备工作\n\n1. github账号\n2. 安装`node.js` 和`npm`\n3. 安装git\n\n## 新建仓库\n\n新建 `bigwonton.github.io`的仓库，以后的访问网站就是`https://bigwonton.github.io`\n\n## 安装hexo\n\n```\nnpm install -g hexo\nnpm install hexo-deploy-git --save //安装插件\n```\n\n<!--more-->\n\n## 初始化\n\n```\nhexo init //初始化\n```\n\n## 配置`_config.yml`\n```\n//下载主题，放在themes文件夹下\ngit clone https://github.com/litten/hexo-theme-yilia.git themes/yilia\n```\n\n修改配置文件\n```\n## 换主题\ntheme: yilia \n\ndeploy:\n  type: git\n  repo: git@github.com:bigwonton/bigwonton.github.io.git\n  branch: master\n```\n\n\n## 上传到github\n```\n\nhexo new 'newArticleName' //新建文章\n\nhexo g   // 生成 html\n\nhexo d   // 上传到github\n\n```\n\n## 其他命令\n\n```\nhexo clean // 清理public文件夹下的内容\n\nhexo new page 'newPageName' //新建页面\n\nhexo s   // 开启本地预览服务 localhost:4000\n\n```\n\n## 多终端写博客\n\n\n### 创建hexo分支\n\n\n配置gitignore文件\n\n```\n/.deploy_git\n/public\n```\n初始化仓库及提交\n\n```\ngit init  //初始化本地仓库\ngit remote add origin git@github.com:bigwonton/bigwonton.github.io.git  //添加远程仓库 <server> 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端\ngit add . //添加本地所有文件到仓库        \ngit commit -m \"更新说明\" //添加commit\ngit checkout -b hexo //创建hexo分支\ngit push origin hexo //将本地仓库的源文件推送到远程仓库\n```\n\n### 新终端初始化\n\n```\ngit clone git@github.com:bigwonton/bigwonton.github.io.git  //克隆hexo分支\nnpm install \n```\n\n\n### 写博客提交方法\n\n```\ngit checkout hexo //切换hexo分支\n\ngit pull //每次写博客之前，先拉取hexo分支最新代码\n```\n\n编辑md文件，提交\n\n```\ngit commit -m \"添加新博客\"\ngit push origin hexo\nhexo g -d //部署\n```\n\n\n\n\n\n","slug":"hexo-github搭建博客","published":1,"updated":"2019-08-18T12:53:47.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzp88mab00047n8uluah6ijq","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>github账号</li>\n<li>安装<code>node.js</code> 和<code>npm</code></li>\n<li>安装git</li>\n</ol>\n<h2 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h2><p>新建 <code>bigwonton.github.io</code>的仓库，以后的访问网站就是<code>https://bigwonton.github.io</code></p>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br><span class=\"line\">npm install hexo-deploy-git --save //安装插件</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init //初始化</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置-config-yml\"><a href=\"#配置-config-yml\" class=\"headerlink\" title=\"配置_config.yml\"></a>配置<code>_config.yml</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下载主题，放在themes文件夹下</span><br><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<p>修改配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 换主题</span><br><span class=\"line\">theme: yilia </span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:bigwonton/bigwonton.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"上传到github\"><a href=\"#上传到github\" class=\"headerlink\" title=\"上传到github\"></a>上传到github</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hexo new &apos;newArticleName&apos; //新建文章</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g   // 生成 html</span><br><span class=\"line\"></span><br><span class=\"line\">hexo d   // 上传到github</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean // 清理public文件夹下的内容</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new page &apos;newPageName&apos; //新建页面</span><br><span class=\"line\"></span><br><span class=\"line\">hexo s   // 开启本地预览服务 localhost:4000</span><br></pre></td></tr></table></figure>\n<h2 id=\"多终端写博客\"><a href=\"#多终端写博客\" class=\"headerlink\" title=\"多终端写博客\"></a>多终端写博客</h2><h3 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h3><p>配置gitignore文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/.deploy_git</span><br><span class=\"line\">/public</span><br></pre></td></tr></table></figure>\n<p>初始化仓库及提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init  //初始化本地仓库</span><br><span class=\"line\">git remote add origin git@github.com:bigwonton/bigwonton.github.io.git  //添加远程仓库 &lt;server&gt; 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端</span><br><span class=\"line\">git add . //添加本地所有文件到仓库        </span><br><span class=\"line\">git commit -m &quot;更新说明&quot; //添加commit</span><br><span class=\"line\">git checkout -b hexo //创建hexo分支</span><br><span class=\"line\">git push origin hexo //将本地仓库的源文件推送到远程仓库</span><br></pre></td></tr></table></figure>\n<h3 id=\"新终端初始化\"><a href=\"#新终端初始化\" class=\"headerlink\" title=\"新终端初始化\"></a>新终端初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:bigwonton/bigwonton.github.io.git  //克隆hexo分支</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h3 id=\"写博客提交方法\"><a href=\"#写博客提交方法\" class=\"headerlink\" title=\"写博客提交方法\"></a>写博客提交方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout hexo //切换hexo分支</span><br><span class=\"line\"></span><br><span class=\"line\">git pull //每次写博客之前，先拉取hexo分支最新代码</span><br></pre></td></tr></table></figure>\n<p>编辑md文件，提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;添加新博客&quot;</span><br><span class=\"line\">git push origin hexo</span><br><span class=\"line\">hexo g -d //部署</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>github账号</li>\n<li>安装<code>node.js</code> 和<code>npm</code></li>\n<li>安装git</li>\n</ol>\n<h2 id=\"新建仓库\"><a href=\"#新建仓库\" class=\"headerlink\" title=\"新建仓库\"></a>新建仓库</h2><p>新建 <code>bigwonton.github.io</code>的仓库，以后的访问网站就是<code>https://bigwonton.github.io</code></p>\n<h2 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br><span class=\"line\">npm install hexo-deploy-git --save //安装插件</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init //初始化</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置-config-yml\"><a href=\"#配置-config-yml\" class=\"headerlink\" title=\"配置_config.yml\"></a>配置<code>_config.yml</code></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下载主题，放在themes文件夹下</span><br><span class=\"line\">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure>\n<p>修改配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 换主题</span><br><span class=\"line\">theme: yilia </span><br><span class=\"line\"></span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: git@github.com:bigwonton/bigwonton.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"上传到github\"><a href=\"#上传到github\" class=\"headerlink\" title=\"上传到github\"></a>上传到github</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hexo new &apos;newArticleName&apos; //新建文章</span><br><span class=\"line\"></span><br><span class=\"line\">hexo g   // 生成 html</span><br><span class=\"line\"></span><br><span class=\"line\">hexo d   // 上传到github</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean // 清理public文件夹下的内容</span><br><span class=\"line\"></span><br><span class=\"line\">hexo new page &apos;newPageName&apos; //新建页面</span><br><span class=\"line\"></span><br><span class=\"line\">hexo s   // 开启本地预览服务 localhost:4000</span><br></pre></td></tr></table></figure>\n<h2 id=\"多终端写博客\"><a href=\"#多终端写博客\" class=\"headerlink\" title=\"多终端写博客\"></a>多终端写博客</h2><h3 id=\"创建hexo分支\"><a href=\"#创建hexo分支\" class=\"headerlink\" title=\"创建hexo分支\"></a>创建hexo分支</h3><p>配置gitignore文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/.deploy_git</span><br><span class=\"line\">/public</span><br></pre></td></tr></table></figure>\n<p>初始化仓库及提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init  //初始化本地仓库</span><br><span class=\"line\">git remote add origin git@github.com:bigwonton/bigwonton.github.io.git  //添加远程仓库 &lt;server&gt; 是指在线仓库的地址 origin是本地分支,remote add操作会将本地仓库映射到云端</span><br><span class=\"line\">git add . //添加本地所有文件到仓库        </span><br><span class=\"line\">git commit -m &quot;更新说明&quot; //添加commit</span><br><span class=\"line\">git checkout -b hexo //创建hexo分支</span><br><span class=\"line\">git push origin hexo //将本地仓库的源文件推送到远程仓库</span><br></pre></td></tr></table></figure>\n<h3 id=\"新终端初始化\"><a href=\"#新终端初始化\" class=\"headerlink\" title=\"新终端初始化\"></a>新终端初始化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:bigwonton/bigwonton.github.io.git  //克隆hexo分支</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h3 id=\"写博客提交方法\"><a href=\"#写博客提交方法\" class=\"headerlink\" title=\"写博客提交方法\"></a>写博客提交方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout hexo //切换hexo分支</span><br><span class=\"line\"></span><br><span class=\"line\">git pull //每次写博客之前，先拉取hexo分支最新代码</span><br></pre></td></tr></table></figure>\n<p>编辑md文件，提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;添加新博客&quot;</span><br><span class=\"line\">git push origin hexo</span><br><span class=\"line\">hexo g -d //部署</span><br></pre></td></tr></table></figure>"},{"title":"AWS+shadowsocks","date":"2018-12-15T12:02:23.000Z","_content":"\n说来惭愧，今天才来折腾翻（he）墙（xie），出来溜达的感觉真好～\n\n## 步骤\n\n- 在这里用到了AWS(Amazon Web Service)，是亚马逊给我们提供的服务，我们可以在`https://amazonaws-china.com/`这里申请服务器。\n- 申请成功并将实例启动之后，进入`AWS管理控制台`，选择左上角的`EC2`，再点击`实例`，`连接`，按照官方的指示，在本地连接上服务器。\n\n\n<!-- more -->\n\n- 然后进行如下操作\n```\nsudo -s \n\napt-get update\n\napt-get install python-pip\n\n\n-- 直接install shadowsocks会报错\nexport LC_ALL=C\n\npip install shadowsocks\n```\n\n- 至此，已经安装好shadowsocks了，下一步就是修改配置文件，然后启动\n\n```\nvi /etc/shadowsocks.json\n```\n\n输入\n```json\n{\n    \"server\":\"0.0.0.0\",\n    \"server_port\":\"yourport\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"yourpassword\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n启动\n```\nssserver -c /etc/shadowsocks.json -d start\n```\n\n- 将shadowsocks加入自启动\n```\nvi /etc/rc.local\n```\n\n添加\n```\nssserver -c /etc/shadowsocks.json -d start\n```\n\n- 最后一步，就是在本机下载shadowsocks客户端了，然后配置服务器的公网ip，开放端口以及密码\n\n下载地址`https://github.com/shadowsocks/ShadowsocksX-NG/releases`","source":"_posts/AWS-shadowsocks.md","raw":"---\ntitle: AWS+shadowsocks\ndate: 2018-12-15 20:02:23\ntags: 工具\n---\n\n说来惭愧，今天才来折腾翻（he）墙（xie），出来溜达的感觉真好～\n\n## 步骤\n\n- 在这里用到了AWS(Amazon Web Service)，是亚马逊给我们提供的服务，我们可以在`https://amazonaws-china.com/`这里申请服务器。\n- 申请成功并将实例启动之后，进入`AWS管理控制台`，选择左上角的`EC2`，再点击`实例`，`连接`，按照官方的指示，在本地连接上服务器。\n\n\n<!-- more -->\n\n- 然后进行如下操作\n```\nsudo -s \n\napt-get update\n\napt-get install python-pip\n\n\n-- 直接install shadowsocks会报错\nexport LC_ALL=C\n\npip install shadowsocks\n```\n\n- 至此，已经安装好shadowsocks了，下一步就是修改配置文件，然后启动\n\n```\nvi /etc/shadowsocks.json\n```\n\n输入\n```json\n{\n    \"server\":\"0.0.0.0\",\n    \"server_port\":\"yourport\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"yourpassword\",\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\": false\n}\n```\n\n启动\n```\nssserver -c /etc/shadowsocks.json -d start\n```\n\n- 将shadowsocks加入自启动\n```\nvi /etc/rc.local\n```\n\n添加\n```\nssserver -c /etc/shadowsocks.json -d start\n```\n\n- 最后一步，就是在本机下载shadowsocks客户端了，然后配置服务器的公网ip，开放端口以及密码\n\n下载地址`https://github.com/shadowsocks/ShadowsocksX-NG/releases`","slug":"AWS-shadowsocks","published":1,"updated":"2019-08-18T12:47:27.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzp88mac00057n8u3yglncsk","content":"<p>说来惭愧，今天才来折腾翻（he）墙（xie），出来溜达的感觉真好～</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>在这里用到了AWS(Amazon Web Service)，是亚马逊给我们提供的服务，我们可以在<code>https://amazonaws-china.com/</code>这里申请服务器。</li>\n<li>申请成功并将实例启动之后，进入<code>AWS管理控制台</code>，选择左上角的<code>EC2</code>，再点击<code>实例</code>，<code>连接</code>，按照官方的指示，在本地连接上服务器。</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>然后进行如下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -s </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install python-pip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-- 直接install shadowsocks会报错</span><br><span class=\"line\">export LC_ALL=C</span><br><span class=\"line\"></span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>至此，已经安装好shadowsocks了，下一步就是修改配置文件，然后启动</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>输入<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"server\"</span>:<span class=\"string\">\"0.0.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"server_port\"</span>:<span class=\"string\">\"yourport\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_address\"</span>:<span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_port\"</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"password\"</span>:<span class=\"string\">\"yourpassword\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"timeout\"</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"fast_open\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>将shadowsocks加入自启动<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/rc.local</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>最后一步，就是在本机下载shadowsocks客户端了，然后配置服务器的公网ip，开放端口以及密码</li>\n</ul>\n<p>下载地址<code>https://github.com/shadowsocks/ShadowsocksX-NG/releases</code></p>\n","site":{"data":{}},"excerpt":"<p>说来惭愧，今天才来折腾翻（he）墙（xie），出来溜达的感觉真好～</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ul>\n<li>在这里用到了AWS(Amazon Web Service)，是亚马逊给我们提供的服务，我们可以在<code>https://amazonaws-china.com/</code>这里申请服务器。</li>\n<li>申请成功并将实例启动之后，进入<code>AWS管理控制台</code>，选择左上角的<code>EC2</code>，再点击<code>实例</code>，<code>连接</code>，按照官方的指示，在本地连接上服务器。</li>\n</ul>","more":"<ul>\n<li><p>然后进行如下操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo -s </span><br><span class=\"line\"></span><br><span class=\"line\">apt-get update</span><br><span class=\"line\"></span><br><span class=\"line\">apt-get install python-pip</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-- 直接install shadowsocks会报错</span><br><span class=\"line\">export LC_ALL=C</span><br><span class=\"line\"></span><br><span class=\"line\">pip install shadowsocks</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>至此，已经安装好shadowsocks了，下一步就是修改配置文件，然后启动</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/shadowsocks.json</span><br></pre></td></tr></table></figure>\n<p>输入<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"server\"</span>:<span class=\"string\">\"0.0.0.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"server_port\"</span>:<span class=\"string\">\"yourport\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_address\"</span>:<span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"local_port\"</span>:<span class=\"number\">1080</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"password\"</span>:<span class=\"string\">\"yourpassword\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"timeout\"</span>:<span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"method\"</span>:<span class=\"string\">\"aes-256-cfb\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"fast_open\"</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>将shadowsocks加入自启动<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/rc.local</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>最后一步，就是在本机下载shadowsocks客户端了，然后配置服务器的公网ip，开放端口以及密码</li>\n</ul>\n<p>下载地址<code>https://github.com/shadowsocks/ShadowsocksX-NG/releases</code></p>"},{"title":"Leetcode 42","toc":true,"_content":"\n## 42. Trapping Rain Water\n\n> Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n\n![image](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\nExample:\n```\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n```\n\n<!--more-->\n\n\n## 分析\n\n这题目看着不难，用栈来做就可以。我的思路是：\n1. 以最大值为划分，分别计算左边和右边的面积和，然后相加\n2. 减去数组的每个值之和\n3. 加上最大值（划分点）的值（因为这个面积没有计算在第1步的和中，第2步却减掉了，所以要加回来）\n\n整体借助了两个stack，栈顶记录着当前位置最大的值。比栈顶大，才入栈，入栈的同时计算到前一个入栈的位置之间包含的面积。\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n         if (height == null || height.length < 1) {\n            return 0;\n        }\n        int res = 0;\n        LinkedList<Integer> lstack = new LinkedList<>();\n        LinkedList<Integer> rstack = new LinkedList<>();\n        int i = 0;\n        for (i = 0; i < height.length; i++) {\n            if (!lstack.isEmpty() && height[lstack.peek()] > height[i]) {\n\n            } else {\n                if (!lstack.isEmpty()) {\n                    res += (height[lstack.peek()] * (i - lstack.peek())) ;\n                }\n                lstack.push(i);\n            }\n        }\n         for (i = height.length - 1; i >= lstack.peek(); i--) {\n            if (!rstack.isEmpty() && height[rstack.peek()] > height[i]) {\n\n            } else {\n                if (!rstack.isEmpty()) {\n                    res += (height[rstack.peek()]) * (rstack.peek() - i);\n                }\n                rstack.push(i);\n            }\n        }\n        for (i = 0; i < height.length; i++) {\n            res -= height[i];\n        }\n        res += height[lstack.peek()];\n\n        // System.out.println(res);\n        return res;\n    }\n}\n```\n\n整个过程中我反复提交了好几次，才通过，犯了以下几个错误：\n1. 没有考虑边界\n2. 从右到左的范围选定错误，导致有一段区域在有些情况重复计算。正确的应该选择从[lstack.peek(),height.length-1]的范围","source":"_posts/刷题记 leetcode 42 Trapping Rain Water.md","raw":"---\ntitle: Leetcode 42\ntags: \n- leetcode\n- 算法\ntoc: true\n---\n\n## 42. Trapping Rain Water\n\n> Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n\n![image](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\nExample:\n```\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n```\n\n<!--more-->\n\n\n## 分析\n\n这题目看着不难，用栈来做就可以。我的思路是：\n1. 以最大值为划分，分别计算左边和右边的面积和，然后相加\n2. 减去数组的每个值之和\n3. 加上最大值（划分点）的值（因为这个面积没有计算在第1步的和中，第2步却减掉了，所以要加回来）\n\n整体借助了两个stack，栈顶记录着当前位置最大的值。比栈顶大，才入栈，入栈的同时计算到前一个入栈的位置之间包含的面积。\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n         if (height == null || height.length < 1) {\n            return 0;\n        }\n        int res = 0;\n        LinkedList<Integer> lstack = new LinkedList<>();\n        LinkedList<Integer> rstack = new LinkedList<>();\n        int i = 0;\n        for (i = 0; i < height.length; i++) {\n            if (!lstack.isEmpty() && height[lstack.peek()] > height[i]) {\n\n            } else {\n                if (!lstack.isEmpty()) {\n                    res += (height[lstack.peek()] * (i - lstack.peek())) ;\n                }\n                lstack.push(i);\n            }\n        }\n         for (i = height.length - 1; i >= lstack.peek(); i--) {\n            if (!rstack.isEmpty() && height[rstack.peek()] > height[i]) {\n\n            } else {\n                if (!rstack.isEmpty()) {\n                    res += (height[rstack.peek()]) * (rstack.peek() - i);\n                }\n                rstack.push(i);\n            }\n        }\n        for (i = 0; i < height.length; i++) {\n            res -= height[i];\n        }\n        res += height[lstack.peek()];\n\n        // System.out.println(res);\n        return res;\n    }\n}\n```\n\n整个过程中我反复提交了好几次，才通过，犯了以下几个错误：\n1. 没有考虑边界\n2. 从右到左的范围选定错误，导致有一段区域在有些情况重复计算。正确的应该选择从[lstack.peek(),height.length-1]的范围","slug":"刷题记 leetcode 42 Trapping Rain Water","published":1,"date":"2019-02-11T16:38:57.778Z","updated":"2019-08-18T12:44:14.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzp88mae00087n8ug1l6nh8h","content":"<h2 id=\"42-Trapping-Rain-Water\"><a href=\"#42-Trapping-Rain-Water\" class=\"headerlink\" title=\"42. Trapping Rain Water\"></a>42. Trapping Rain Water</h2><blockquote>\n<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>\n</blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" alt=\"image\"></p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class=\"line\">Output: 6</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>这题目看着不难，用栈来做就可以。我的思路是：</p>\n<ol>\n<li>以最大值为划分，分别计算左边和右边的面积和，然后相加</li>\n<li>减去数组的每个值之和</li>\n<li>加上最大值（划分点）的值（因为这个面积没有计算在第1步的和中，第2步却减掉了，所以要加回来）</li>\n</ol>\n<p>整体借助了两个stack，栈顶记录着当前位置最大的值。比栈顶大，才入栈，入栈的同时计算到前一个入栈的位置之间包含的面积。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (height == <span class=\"keyword\">null</span> || height.length &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; lstack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; rstack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; height.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!lstack.isEmpty() &amp;&amp; height[lstack.peek()] &gt; height[i]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!lstack.isEmpty()) &#123;</span><br><span class=\"line\">                    res += (height[lstack.peek()] * (i - lstack.peek())) ;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lstack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (i = height.length - <span class=\"number\">1</span>; i &gt;= lstack.peek(); i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rstack.isEmpty() &amp;&amp; height[rstack.peek()] &gt; height[i]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!rstack.isEmpty()) &#123;</span><br><span class=\"line\">                    res += (height[rstack.peek()]) * (rstack.peek() - i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                rstack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; height.length; i++) &#123;</span><br><span class=\"line\">            res -= height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res += height[lstack.peek()];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(res);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个过程中我反复提交了好几次，才通过，犯了以下几个错误：</p>\n<ol>\n<li>没有考虑边界</li>\n<li>从右到左的范围选定错误，导致有一段区域在有些情况重复计算。正确的应该选择从[lstack.peek(),height.length-1]的范围</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"42-Trapping-Rain-Water\"><a href=\"#42-Trapping-Rain-Water\" class=\"headerlink\" title=\"42. Trapping Rain Water\"></a>42. Trapping Rain Water</h2><blockquote>\n<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>\n</blockquote>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png\" alt=\"image\"></p>\n<p>Example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class=\"line\">Output: 6</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>这题目看着不难，用栈来做就可以。我的思路是：</p>\n<ol>\n<li>以最大值为划分，分别计算左边和右边的面积和，然后相加</li>\n<li>减去数组的每个值之和</li>\n<li>加上最大值（划分点）的值（因为这个面积没有计算在第1步的和中，第2步却减掉了，所以要加回来）</li>\n</ol>\n<p>整体借助了两个stack，栈顶记录着当前位置最大的值。比栈顶大，才入栈，入栈的同时计算到前一个入栈的位置之间包含的面积。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">trap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] height)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (height == <span class=\"keyword\">null</span> || height.length &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; lstack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; rstack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; height.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!lstack.isEmpty() &amp;&amp; height[lstack.peek()] &gt; height[i]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!lstack.isEmpty()) &#123;</span><br><span class=\"line\">                    res += (height[lstack.peek()] * (i - lstack.peek())) ;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                lstack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (i = height.length - <span class=\"number\">1</span>; i &gt;= lstack.peek(); i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!rstack.isEmpty() &amp;&amp; height[rstack.peek()] &gt; height[i]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!rstack.isEmpty()) &#123;</span><br><span class=\"line\">                    res += (height[rstack.peek()]) * (rstack.peek() - i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                rstack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; height.length; i++) &#123;</span><br><span class=\"line\">            res -= height[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res += height[lstack.peek()];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// System.out.println(res);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个过程中我反复提交了好几次，才通过，犯了以下几个错误：</p>\n<ol>\n<li>没有考虑边界</li>\n<li>从右到左的范围选定错误，导致有一段区域在有些情况重复计算。正确的应该选择从[lstack.peek(),height.length-1]的范围</li>\n</ol>"},{"title":"《SQL学习指南》笔记","date":"2018-12-15T11:14:45.000Z","toc":true,"_content":"\n\n### 创建和使用数据库\n\n- 主键约束\n`constraint pk_person primary key (person_id)`\n\n- 检查约束\n`gender char(1) check (gender in ('M','F')),`\n\n或用`gender ENUM('M','F'),`代替检查约束\n\n<!--more-->\n\n\n```sql\n create table person\n (person_id smallint unsigned,\n fname varchar(20),\n lname varchar(20),\n gender enum('M','F'),\n birth_date date,\n street varchar(30),\n city varchar(20),\n state varchar(20),\n country varchar(20),\n postal_code varchar(20),\n constraint pk_person primary key (person_id)\n );\n```\n\n\n\n```sql\ncreate table favorite_food\n(person_id smallint unsigned,\nfood varchar(20),\nconstraint pk_favorite_food primary key (person_id, food),\nconstraint fk_fav_food_person_id foreign key (person_id)\nreferences person (person_id)\n);\n```\n\n**此时想要给person表主键增加auto_incremnt**\n```\nalter table person modify person_id smallint unsigned auto_increment;\n```\n报错，\n```\nError Code: 1833. Cannot change column 'person_id': used in a foreign key constraint 'fk_fav_food_person_id' of table 'table.favorite_food'\n```\n，因为被用在favorite_food表中作为外键了，不允许修改，\n\n==Solution 1==：\n\n```\nlock tables \nfavorite_food write,\nperson write;\n```\n```\nalter table favorite_food \ndrop foreign key fk_fav_food_person_id,\nmodify person_id smallint unsigned;\n```\n然后再修改person主键\n```\nalter table person modify person_id smallint unsigned auto_increment;\n```\n\n创建外键\n```\nalter table favorite_food \nadd constraint fk_fav_food_person_id foreign key (person_id) \nreferences person (person_id);\n```\n```\nunlock tables;\n```\n\n==solution 2==\n\nYou can turn off foreign key checks:\n\n\n```\nSET FOREIGN_KEY_CHECKS = 0;\n\n/* DO WHAT YOU NEED HERE */\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n插入一条数据\n```\ninsert into person \n(person_id, fname, lname,gender,birth_date) \nvalues (null, 'William', 'Turner','M','1972-05-27');\n```\n\n```\ninsert into favorite_food (person_id,food) \nvalues (1, 'pizza');\ninsert into favorite_food (person_id,food) \nvalues (1, 'cookies');\ninsert into favorite_food (person_id,food) \nvalues (1, 'nachos');\n```\n\n更新数据\n```\nupdate person \nset street='1225 Tremont St.',\ncity='Boston',\nstate='MA',\ncountry='USA',\npostal_code='02138' \nwhere person_id=1;\n```\n\n删除数据\n```\ndelete from person \nwhere person_id=2;\n```\n\n\n### 查询\n\n```\nselect emp_id \n'ACTIVE',\nemp_id * 3.14159,\nUPPER(lname) \nfrom employee;\n```\n\n执行内建函数或对简单的表达式求值可以完全省略from子句：\n```\nselect version(),\nuser(),\ndatabase();\n```\n\n#### 列的别名：\n\n```\nselect emp_id,\n'ACTIVE' status,\nemp_id * 3.14159 empid_x_pi,\nUPPER(lname) last_name_upper \nfrom employee;\n```\n\n(可以在别名前加上AS关键字)\n\n\n#### 去除重复的行\n\n```\nselect distinct cust_id \nfrom account;\n```\n\n==注：产生无重复的结果集需要首先对数据排序，因此，不要为了确保去重二使用DiSTINCT，而应先了解所使用的数据是否可能包含重复的行。==\n\n\n#### from子句\n\nfrom子句定义了查询中所使用的表，以及连接这些表的方式。\n\n- 表\n    - 永久表（create table语句创建的表）\n    - 临时表（子查询返回的表）\n    - 虚拟表（create view）\n\n通过别名e来引用子查询：\n```\nselect e.emp_id, e.fname, e.lname \nfrom (select emp_id,fname,lname,start_date,title \nfrom employee) e;\n```\n\n视图是存储在数据字典中的查询，它的行为表现的像一个表，但实际上并不拥有任何数据（因此称为虚拟表）。当发出一个对视图的查询时，该查询会被绑定到视图定义上，以产生最终被执行的查询。\n\n1. 定义一个查询employee表的视图\n\n```\ncreate view employee_vw AS \nselect emp_id, fname, lname, \nYEAE(start_date) start_year \nfrom employee;\n```\n\n2. 查询视图\n\n```\nselect emp_id, start_year \nfrom employee_vw;\n```\n\n##### 表连接\n\n```\nselect employee.emp_id,employee.fname,employee.lname,\ndepartment.name dept_name \nfrom employee inner join department \non employee.dept_id=department.dept_id;\n```\n\n##### 定义表别名\n\n```\nselect e.emp_id,e.fname,e.lname,\nd.name dept_name \nfrom employee e inner join department d \non e.dept_id=d.dept_id;\n```\n\n#### where子句\n\n```\nselect emp_id,fname,lname,start_date,title \nfrom employee \nwhere title='Head Teller' \nAND start_date > '2006-01-01';\n```\n\n\n#### group by和having子句\n\n```\nselect d.name,count(e.emp_id) num_employees \nfrom department d inner join employee e \non d.dept_id=e.dept_id \ngroup by d.name \nhaving count(e.emp_id) > 2;\n```\n\n#### order by\n\n```\nselect open_emp_id, product_id \nfrom account \norder by open_emp_id;\n```\n\n- 升序（ASC、默认）\n- 降序DESC\n\n##### 根据表达式排序\n\n使用right()内建函数提取fed_id列的最后三个字符排序：\n\n```\nselect cust_id,cust_type_cd,city,state,fed_id \nfrom customer \norder by right(fed_id, 3);\n```\n\n##### 根据数字占位符排序\n\n根据查询返回的第2，5列排序： \n```\nselect emp_id,title,start_date,fname.lname \nfrom employee \norder by 2,5;\n```\n\n### 过滤\n\n#### 条件类型\n\n\n```\nselect pt.name product_type,p.name product \nfrom product p inner join product_type pt \non p.product_type_cd = pt.product_type_cd \nwhere pt.name = 'Customer Accounts';\n```\n\n不等条件：\n```\nselect pt.name product_type,p.name product \nfrom product p inner join product_type pt \non p.product_type_cd = pt.product_type_cd \nwhere pt.name <> 'Customer Accounts';\n```\n\n描述不等条件时，可以用`<>`也可以用`!=`\n\n\n##### 范围条件\n\n```\nselect emp_id,fname,lname,start_date \nfrom employee \nwhere start_date<'2007-01-01';\n```\n\n```\nselect emp_id,fname,lname,start_date \nfrom employee \nwhere start_date <'2007-01-01' \nand start_date >= '2005-01-01';\n```\n\nbetween(两端都是包含)\n\n```\nselect emp_id,fname,lname,start_date \nfrom employee \nwhere start_date between '2005-01-01' and '2006-12-31';\n```\n\n```\nselect cust_id,fed_id \nfrom customer \nwhere cust_type_cd='I'\nand fed_id between '500-00-0000' and '999-99-9999';\n```\n\nin操作符\n\n```\nselect account_id,product_id,cust_id,avail_balance \nfrom account \nwhere product_cd in ('CHK','SAV','CD,'MM');\n```\n\n```\nselect account_id,product_id,cust_id,avail_balance \nfrom account \nwhere product_cd in (select product_cd from product \nwhere product_type_cd = 'ACCOUNT');\n```\n\n\nnot in\n```\nselect account_id,product_cd,cust_id,avail_balance \nfrom account \nwhere product_cd not in ('CHK','SAV','CD','MM');\n```\n\n##### 匹配条件\n\n```\nselect emp_id,fname,lname \nfrom employee \nwhere left(lname,1)='T';\n```\n\n可以使用内建函数left()，但更好的做法是使用通配符：\n```\nselect lname \nfrom employee \nwhere lname like '_a%e%';\n```\n\n```\nselect cust_id,fed_id \nfrom customer \nwhere fed_id like '___-__-____';\n\n```\n\n```\nselect emp_id,fname,lname \nfrom employee\nwhere lname like 'F%' or lname like 'G%';\n```\n\n##### 正则表达式\n\n```\nselect emp_id,fname,lname \nfrom employee \nwhere lname regexp '^[FG]';\n```\n\n#### NULL\n\n```\nselect emp_id,fname,lname,superior_emp_id \nfrom employee \nwhere superior_emp_id is NULL;\n```\n\n### 多表查询\n\n##### 笛卡尔积\n\n交叉连接\n\n```\nselect e.fname,e.lname,d.name \nfrom employee e join department d;\n```\n\n##### 内连接\n\n如果在一个表中的dept_id列中存在某个值，但该值在另一张表的dept_id列中不存在，那么相关行的连接会失败，在结果集中将会排除包含该值的行。\n\n```\nselect e.fname,e.lname,d.name \nfrom employee e join department d \non e.dept_id = d.dept_id;\n```\n\n- 上面没加inner关键字，默认使用inner，但最好加上。\n- 如果连接两个表的列名是相同的，可以使用using子句代替on子句：\n\n```\nselect e.fname,e.lname,d.name \nfrom employee e inner join department d \nusing (dept_id);\n```\n\n\n#### 连接3个或更多的表\n\n```\nselect a.account_id,c.fed_id,e.fname,e.lname \nfrom account a inner join customer c \non a.cust_id=c.cust_id \ninner join employee e \non a.open_emp_id = e.emp_id \nwhere c.cust_type_cd = 'B';\n```\n\n\n\n##### 将子查询结果作为查询表\n\n```\nselect a.account_id,a.cust_id,a.open_date,a.product_cd \nfrom account a INNER JOIN \n    (select emp_id,assigned_branch_id \n    from employee \n    where start_date < '2007-01-01' \n    and (title = 'Teller' OR title = 'Head Teller')) e\n    ON a.open_emp_id = e.emp_id \n    INNER JOIN\n        (select branch_id \n        from branch \n        where name = 'Woburn Branch') b \n        ON e.assigned_branch_id = b.branch_id;\n```\n\n##### 连续两次使用同一个表\n\n需要给每个branch表的实例定义不用的别名\n\n```\nselect a.account_id,e.emp_id,\nb_a.name open_branch,b_e.name emp_branch \nfrom account a inner join branch b_a \non a.open_branch_id=b_a.branch_id \ninner join employee e \non a.open_emp_id=e.emp_id \ninner join branch b_e \non e.assigned_branch_id=b_e.branch_id \nwhere a.product_cd='CHK';\n```\n\n#### 自连接\n\n```\nselect e.fname,e.lname \ne_mgr.fname mgr_fname,e_mgr.lname mgr_lname \nfrom employee e inner join employee e_mgr \non e.superior_emp_id = e_mgr.emp_id;\n```\n\n上面语句列出了雇员姓名和主管姓名，但是employee表中一共有18行，但此查询只返回17行，这是由于银行的总经理并没有自己的主管（superior_emp_id列为null），因此在该行连接失败了。为了在结果集中包含这个数据，应使用外连接。\n\n\n```\nselect e1.fname, e1.lname, 'VS' vs, e2.fname, e2.lname \nfrom employee e1 inner join employee e2 \non e1.emp_id < e2.emp_id \nwhere e1.title='Teller' and e2.title = 'Teller';\n```\n\n#### 连接条件和过滤条件\n\n```\nselect a.account_id, a.product_cd, c.fed_id \nfrom account a inner join customer c \non a.cust_id = c.cust_id \nwhere c.cust_type_cd = 'B';\n```\n\n\n### 使用集合\n\n- 当对两个数据集合执行集合操作时，必须满足：\n    - 两个数据集合必须具有同样数目的列\n    - 两个数据集中对应列的数据类型必须是一样的（或者服务器能偶从一种转换成另一种）\n\n```\nselect 1 num, 'abc' str \nunion \nselect 9 num, 'xyz' str;\n```\n\n\n##### union操作符\n\nunion对连接后的集合排序并去除重复项，而union all保留重复项。\n\n```\nselect 'IND' type_cd, cust_id, lname name \nfrom individual \nunion all \nselect 'BUS' type_cd, cust_id, name \nfrom business;\n```\n\n\n返回重复数据：\n\n```\nselect emp_id \nfrom employee \nwhere assigned_branch_id=2 \nand (title='Teller' or title='Head Teller') \nunion all \nselect distinct open_emp_id \nfrom account \nwhere open_branch_id = 2;\n```\n\n查询结果含有重复项，如果要排除重复项，需要把union all改成union\n\n\n##### intersect 操作符\n\n\nintersect 查找交集，并且去除了交集区域中所有重复的行，不删除重复的的是intersect all操作符\n\n```\nselect emp_id \nfrom employee \nwhere assigned_branch_id=2 \nand (title='Teller' or title='Head Teller') \nintersect  \nselect distinct open_emp_id \nfrom account \nwhere open_branch_id = 2;\n```\n\n##### except操作符\n\nexcept操作符返回第一个表减去第二个表重合的元素后剩下的部分。\nexcept在集合A中去除所有的重复数据，而except all则根据重复数据在集合B中出现的次数进行删除。\n\n```\nselect emp_id \nfrom employee \nwhere assigned_branch_id=2 \nand (title='Teller' or title='Head Teller') \nexcept   \nselect distinct open_emp_id \nfrom account \nwhere open_branch_id = 2;\n```\n\n\n##### 集合操作符优先级\n\n```\nselect cust_id \nfrom account \nwhere product_cd in ('SAV','MM') \nunion all \nselect a.cust_id \nfrom account a inner join branch b \non a.open_branch_id = b.branch_id \nwhere b.name = 'Woburn Branch' \nunion \nselect cust_id \nfrom account \nwhere avail_balance between 500 and 2500;\n```\n\n复合查询包含3个或3个以上的查询语句，他们是自顶向下的顺序解析和执行的，但要注意：\n\n- 在调用集合操作时，intersect操作符比其他操作符具有更高的优先级\n- 可以用圆括号对多个查询进行封装，以明确指定他们的指定次序\n\nMySQL 没有实现intersect操作符\n\n### 数据生成、转换和操作\n\n#### 使用字符串数据\n\n- `CHAR`\n    - 固定长度，不足部分使用空格填充的字符串\n    - MySQL的CHAR类型的长度为255字节。\n    - Oracle为2000\n    - SQL Server 8000\n- `varchar`\n    - 变长字符串。\n    - MySQL允许的varchar列最多包含65536个字符\n    - Oracle为4000\n    - SQL Server为8000\n- `text`(MySQL和SQL Server) 或 `CLOB`(Character Large Object; Oracle)\n    - MySQL有多种text类型，最多4GB\n    - SQL只有text，最长2GB\n    - Oracle的CLOB，最大128TB\n\n\n```\ncreate table string_tbl\n(char_fld CHAR(30),\nvchar_fld varchar(30),\ntext_fld text);\n```\n\n##### 生成字符串\n\nMySQL 6.0中，默认行为是“strict”模式，发生问题时抛出异常，而在早先的服务器版本中，默认方式是截断字符串并发出一个警告。如果希望数据库引擎采取后一种方式，可以将之修改为ANSI模式。\n\n- 查看数据库当前模式\n\n```\nselect @@session.sql_mode;\n```\n\n- 改变当前模式\n\n```\nset sql_mode='ansi';\n```\n\n==由于服务器是在纯粹字符串时按需分配空间，因此不会因为将varchar列的上限值设的比较大而浪费资源。==\n\n- 单引号转义符\n\n```\nupdate string_tb1 set text_fld='This string didn''t work, but it does now';\n```\n\n可以使用单引号作为转义符\n\n```\nupdate string_tb1 set text_fld='This string didn\\'t work, but it does now';\n```\n\n- 使用内建函数quote()，他用单引号将整个字符串包含起来，并为字符串本身的单引号/撇号增加转义符：\n```\nselect quote(text_fld) \nfrom string_tbl;\n```\n\n- 包含特殊字符 \n```\nselect 'abcdefg', CHAR(97,98,99,100,101,102,103);\n```\n\n```\nselect CHAR(138,139,140,141,142,143,144,145,146,147);\n```\n\n```\nselect concat('danke sch', char(148), 'n');\n```\n\n字符串长度：\n```\nselect length(char_fld) char_length,\nlength(vchar_fld) varchar_length,\nlength(text_fld) text_length \nfrom string_tbl;\n```\n\n字符串位置：\n```\nselect position('characters' in vchar_fld) \nfrom string_tbl;\n```\n\n如果找不到该子字符串，那么position()函数将返回0.\n\n\n从任意位置开始查找字符串位置：\n\n```\nselect locate('is', vchar_fld, 5) \nfroom string_tbl;\n```\n\n字符串比较（只有mysql）\n\nmysql的strcmp()大小写不敏感\n\n```\nselect strcmp('12345', 'abc') 12345_abc,\nstrcmp('abcd', 'xyz') abcd_xyz,\nstrcmp('qrstuv', 'QRSTUV') qrstuv_QRSTUV;\n```\n\n- like\n```\nselect name,name like '%ns' ends_in_ns \nfrom department;\n```\n\n```\nselect cust_id, cust_type_cd, fed_id, \nfed_id regexp '_{3}-_{2}-_{4}' is_ss_no_format \nfrom customer;\n```\n\n- concat()\n```\nupdate string_tbl \nset text_fld = concat(text_fld, ', but now it is longer');\n```\n\nOracle下，可以使用连接操作符`||`代替concat()进行字符串连接\nSQL Server并么有concat()函数，使用的是连接操作符`+`\n\n- 插入字符串 insert()\n```\nselect insert('goodbye world', 9, 0, 'cruel ') string;\n```\n\n如果第三个参数大于0，那么相应数目的字符将会被替换字符串所取代：\n\n```\nselect insert('goodbye world', 1, 7, 'hello') string;\n```\n\nOracle数据没有提供MySQL中的insert()类似函数，但他的replace()函数也可以用于替换字符串：\n\n```\nselect replace('goodbye world', 'goodbye', 'hello') from dual;\n```\n\nSQL Server 同样包含replace()函数，除此之外，还包含stuff()函数：\n```\nselect stuff('hello world', 1, 5, 'goodbye cruel');\n```\n\n- 子串 substring()\n```\nselect substring('goodbye cruel world', 9, 5);\n```\n\n#### 使用数值数据\n\n```\nselect (37 * 59) / (78 - (8 * 6));\n```\n\n```\nselect mod(10,4);\n\nselect pow(2, 8);\n\n\n```\n\n##### 控制数字经度\n\n- ceil()\n- floor()\n- round() 四舍五入，保留n位小数\n- truncate() 直接舍掉后面的\n```\nselect ceil(72.445),floor(72.445);\n```\n\n结果:`73    72`\n\n```\nselect round(72.4999),round(72.5);\n\nselect round(72.0909, 1), round(72.0909,2), round(72.0909, 3);\n```\n\n```\nselect truncate(72.0909,1), truncate(72.0909,2), truncate(72.0909,3);\n```\n\ntruncate()和round()第二个参数都可以指定为负数：\n```\nselect round(17, -1), truncate(17, -1);\n```\n\n结果：\n`20  10`\n\n##### 处理有符号数\n\n```\nselect account_id, sign(avail_balance), abs(avail_balance) \nfrom account;\n```\n\n- sign()函数取符号\n- abs()函数取绝对值\n\n#### 使用时间数据\n\n- 时区设置：全局时区和会话时区\n\n```\nselect @@global.time_zone,@@session.time_zone;\n```\n\n服务器自动将字符串适配到datetime列：\n```\nupdate transaction \nset txn_date = '2008-09-17 15:30:00' \nwhere txn_id = 99999;\n```\n\n使用cast()函数转换\n\n```\nselect cast('2008-09-17 15:30:00' as datetime);\n\nselect cast('2009-09-17' as date) date_field \nselect cast('108:17:57' as time) time_field;\n```\n\n\n\n- `str_to_date()`函数  将字符串格式化为日期\n```\nupdate individual \nset birth_date = str_to_date('September 17, 2008', '%M %d, %Y') \nwhere cust_id = 9999;\n```\n\n- 当前日期\n```\nselect current_date(), current_time(), current_timestamp();\n```\n\n- 当前日期加上5天 `date_add()`\n```\nselect date_add(current_date(), interval 5 day);\n```\n\n```\nupdate transaction \nset txn_date = date_add(txn_date, interval '3:27:11' hour_second) \nwhere txn_id = 9999;\n```\n\n- 当月最后一天  `last_day()`\n```\nselect last_day('2008-09-17');\n```\n\n\n- 返回某一天是星期几 `dayname()`\n```\nselect dayname('2008-09-18');\n```\n- 提取日期值中的信息 `extract()`函数\n```\nselect extract(year from '2008-09-18 22:19:05');\n```\n\n- 时间间隔 `datediff()`\n```\nselect datediff('2009-09-03', '2009-06-24');\n```\n\n\n#### 转换函数\n\n- `cast()`\n\n```\nselect cast('14567' as signed integer);\n```\n\n遇到非数字的字符，转换将中止并不返回错误：\n```\nselct cast('999ABC111' as unsigned integer);\n```\n\n### 分组与聚集\n\n- group by\n\n- 分组\n```\nselect open_emp_id \nfrom account \ngroup by open_emp_id;\n```\n\n- 分组，并查看每一个分组的数量\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id;\n```\n\n- 过滤出条数大于4的分组，需要用having，不能用where，因为用where过滤的时候，还未分组\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \nhaving count(*) > 4;\n```\n#### 聚集函数\n\n- Max()\n- Min()\n- Avg()\n- Sum()\n- Count()\n\n##### 隐式或显式分组\n\n```\nselect max(avail_balance) max_balance,\nmin(avail_balance) min_balance,\navg(avail_balance) avg_balance,\nsum(avail_balance) sum_balance,\ncount(*) num_accounts \nfrom account \nwhere product_cd = 'CHK';\n```\n\n上个例子中，查询返回的每个值都是由聚集函数产生的，这些聚集函数作用于使用过滤条件product_cd='CHK'指定的分组上的所有行。这里没有使用group by子句，因此它是一个隐式分组（即包含查询返回的所有行）。\n\n但如果同时需要提取product_cd列，如下：\n```\nselect product_cd,\nmax(avail_balance) max_balance,\nmin(avail_balance) min_balance,\navg(avail_balance) avg_balance,\nsum(avail_balance) sum_balance,\ncount(*) num_accounts \nfrom account;\n```\n\n将会报错，因为没有显式地指定如何对数据分组。改为：\n```\nselect product_cd,\nmax(avail_balance) max_balance,\nmin(avail_balance) min_balance,\navg(avail_balance) avg_balance,\nsum(avail_balance) sum_balance,\ncount(*) num_accounts \nfrom account \ngroup by product_cd;\n```\n\n\n##### 对独立值计数\n\n```\nselect count(open_emp_id)\nfrom account;\n```\n\n去除重复的行统计：\n```\nselect count(distinct open_emp_id) \nfrom account;\n```\n\n##### 对null的计算\n\ncount(*) 计算所有行\ncount(val) 会忽略null\n\n#### 产生分组\n##### 单列分组\n\n```\nselect product_cd, sum(avail_balance) prod_balance \nfrom account \ngroup by product_cd;\n```\n\n##### 对多列的分组\n```\nselect product_cd,open_branch_id, \nsum(avail_balance) tot_balance \nfrom account \ngroup by product_cd, open_branch_id;\n```\n\n##### 利用表达式分组\n\n```\nselect extract(year form start_date) year,\ncount(*) how_many \nfrom employee \ngroup by extract(year from start_date);\n```\n\n##### 产生合计数 with rollup\n\n- 独立产品也进行合计，最后还会产生总的合计\n\n```\nselect product_cd, open_branch_id,\nsum(avail_balance) tot_balance \nfrom account \ngroup by product_cd, open_branch_id with rollup;\n```\n\n#### 分组过滤条件\n\n- 分组前——用where过滤\n- 分组后——用having过滤\n \n```\nselect product_cd, sum(avail_balance) prod_balance \nfrom account \nwhere status = 'ACTIVE' \ngroup by product_cd \nhaving sum(avail_balance) >=10000;\n```\n\n### 子查询\n\n```\nselect account_id,product_id,cust_id,avail_balance \nfrom account \nwhere open_emp_id <> (select e.emp_id \nfrom employee e inner join branch b \non e.assigned_branch_id = b.branch_id \nwhere e.title = 'Head Teller' and b.city = 'Woburn');\n```\n\n上述子查询只有一个结果，否则会报错。\n\n#####  多行单列子查询\n- in 和 not in运算分\n```\nselect branch_id, name, city \nfrom branch \nwhere name in ('Headquarters', 'Quincy Branch');\n```\n\n查询所有主管：\n```\nselect emp_id, fname, lname, title \nfrom employee \nwhere emp_id in (select superior_emp_id \nfrom employee);\n```\n\n查询所有不管理别人的雇员：\n\n```\nselect emp_id, fname, lname, title \nfrom employee \nwhere emp_id not in (select superior_emp_id \nfrom employee \nwhere superior_emp_id is not null);\n```\n\n- all运算符 \n将某单值与集合中的每个值进行比较：\n\n 查询非主管雇员：\n```\nselect emp_id, fname, lname, title \nfrom employee \nwhere emp_id <> all (select superior_emp_id \nfrom employee \nwhere superior_emp_id is not null);\n```\n\n==当使用not in或<>运算符比较一个值和一个值集时，必须确保值集中不包含null值，因为服务器将表达式左边的值与null比较时，都将产生未知的结果。==\n\n\n\n- any运算符\n\nany运算符只要有一个比较成立，则条件为真。all需要都成立才为真。\n\n```\nselect account_id,cust_id,product_cd, avail_balance \nfrom account \nwhere avail_balance > any (select a.avail_balance \nfrom account a inner join individual i \non a.cust_id = i.cust_id \nwhere i.fname = 'Frank' and i.lname = 'Tucker');\n```\n\n\n##### 多列子查询\n\n- 多重单列子查询：\n```\nselect account_id, product_id, cust_id \nfrom account \nwhere open_branch_id = (select branch_id \nfrom branch \nwhere name = 'Woburn Branch') \nand open_emp_id in (select emp_id \nfrom employee \nwhere title = 'Teller' or title = 'Head Teller');\n```\n\n等同于下面的 多列子查询：\n```\nselect account_id, product_id, cust_id \nfrom account \nwhere (open_branch_id, open_emp_id) in \n(select b.branch_id, e.emp_id \nfrom branch b inner join employee e \non b.branch_id = e.assigned_branch_id \nwhere b.name = 'Woburn Branch' \nand (e.title = 'Teller' or e.title = 'Head Teller'));\n```\n\n#### 关联子查询\n\n子查询最后引用的c.cust_id使之具有关联性，这样他的执行必须依赖于包含查询提供的c.cust_id。\n```\nselect c.cust_id, c.cust_type_cd, c.city \nfrom customer c \nwhere 2 = (select count(*) \nfrom account a \nwhere a.cust_id = c.cust_id);\n```\n\n```\nselect c.cust_id, c.cust_type_cd, c.city\nfrom customer c \nwhere (select sum(a.avail_balance) \nfrom account a \nwhere a.cust_id = c.cust_id)\nbetween 5000 and 10000;\n```\n\n\n```\nselect 'ALTER! : Account #1 Hs Incorrect Balance!' \nfrom account \nwhere (avail_balance, pending_balance) <> ¡™\n(select sum(<expression to generate available balance>), \nsum(<expression to generate pending balance>) \nfrom transaction \nwhere account_id = 1) \nand account_id = 1;\n```\n\n对于上面的例子，用关联子查询代替非关联子查询，升级为：\n```\nselect 'ALTER! : Account #1 Hs Incorrect Balance!' \nfrom account t \nwhere (avail_balance, pending_balance) <> \n(select sum(<expression to generate available balance>), \nsum(<expression to generate pending balance>) \nfrom transaction t \nwhere t.account_id = a.account_id);\n```\n\n##### exists 运算符\n\nexists运算符是构造包含关联子查询条件最常用的运算符。\n\n```\nselect a.account_id, a.product_cd, a.cust_id, a.avail_balance \nfrom account a \nwhere exists (select 1 \nfrom transaction t \nwhere t.account_id = a.account_id \nand t.txn_date = '2008-09-22');\n```\n\n- not exists\n\n```\nselect a.account_id, a.product_cd, a.cust_id \nfrom account a \nwhere not exists (select 1 \nfrom business b \nwhere b.cust_id = a.cust_id);\n```\n##### 关联子查询操作数据\n\n```\nupdate account a \nset a.last_activity_date = \n(select max(t.txn_date) \nfrom transaction t \nwhere t.account_id = a.account_id);\n```\n\n但是上面的子查询语句没有检查每个账户是否发生过交易，否则有可能为null，因此修改为：\n```\nupdate account a \nset a.last_activity_date = \n(select max(t.txn_date) \nfrom transaction t \nwhere t.account_id = a.account_id) \nwhere exists (select 1 \nfrom transaction t \nwhere t.account_id = a.account_id);\n```\n\n删除没有员工的部门：\n\n```\ndelete from department \nwhere not exists (select 1 \nfrom employee \nwhere employee.dept_id = department.dept_id);\n```\n\n==注：在MySQL中delete语句使用关联子查询时，不能使用表别名。==\n\n\n查找开户数最多的雇员：\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \nhaving count(*) = (select max(emp_cnt.how_many) \nfrom (select count(*) how_many \nfrom account \ngroup by open_emp_id) emp_cnt);\n```\n\n\n\n检索雇员数据，排序第一准则是老板姓氏，第二是雇员的姓氏：\n```\nselect emp.emp_id, concat(emp.fname, ' ', emp.lname) emp_name, \n(select concat(boss.fname, ' ', boss.lname) \nfrom employee boss \nwhere boss.emp_id = emp.superior_emp_id) boss_name \nfrom employee emp \nwhere emp.superior_emp_id is not null \norder by (select boss.lname from employee boss \nwhere boss.emp_id = emp.superior_emp_id), emp.lname;\n```\n\n\n### 再谈连接\n\n#### 外连接\n\n```\nselect a.account_id, a.cust_id, b.name \nfrom account a left outer join business b \non a.cust_id = b.cust_id;\n```\n\n\n##### 左外连接与右外连接\n\nleft指连接左边的表决定结果集的行数，而右边只负责提供与之匹配的列值：\n```\nselect c.cust_id,b.name \nfrom customer c left outer join business b \non c.cust_id = b.cust_id;\n```\n\n如果是右链接：\n```\nselect c.cust_id,b.name \nfrom customer c right outer join busines b \nwhere c.cust_id = b.cust_id;\n```\n\n##### 三路外连接\n\n```\nselect a.account_id, a.product_cd, \nconcat(i.fname, ' ', i.lname) person_name,\nb.name business_name \nfrom account a left outer join individual i \non a.cust_id = i.cust_id \nleft outer join business b \non a.cust_id = b.cust_id;\n```\n\n如果mysql对于外连接到同一个表的其他表的树木有限制，那么可以这么重写：\n```\nselect account_ind.account_id, account_ind.product_cd,\naccount_ind.person_name,\nb.name business_name \nfrom \n(select a.account_id, a.product_cd, a.cust_id, \nconcat(i.fname, ' ', i.lname) person name \nfrom account a left outer join individual i \non a.cust_id = i.cust_id) account_ind \nleft outer join business b \non account_ind.cust_id = b.cust_id;\n```\n\n\n##### 自外连接\n\n```\nselect e.fname, e.lname,\ne_mgr.fname mgr_fname, e_mgr.lname mgr_lname \nfrom employee e left outer join employee e_mgr \non e.superior_emp_id = e_mgr.emp_id;\n```\n#### 交叉连接\n\n```\nselect pt.name, p.product_cd, p.name \nfrom product p cross join product_type pt;\n```\n\n- 生成2008年全年日期\n```\nselect date_add('2008-01-01', interval (ones.num + tens.num + hundreds.num) day) dt  \nfrom \n(select 0 num union all \nselect 1 num union all \nselect 2 num union all \nselect 3 num union all \nselect 4 num union all \nselect 5 num union all \nselect 6 num union all \nselect 7 num union all \nselect 8 num union all \nselect 9 num) ones \ncross join \n(select 0 num union all \nselect 10 num union all \nselect 20 num union all \nselect 30 num union all \nselect 40 num union all \nselect 50 num union all \nselect 60 num union all \nselect 70 num union all \nselect 80 num union all \nselect 90 num) tens  \ncross join \n(select 0 num union all \nselect 100 num union all \nselect 200 num union all \nselect 300 num) hundreds \nwhere date_add('2008-01-01', \ninterval(ones.num+tens.num+hundreds.num) day) < '2009-01-01' \norder by 1;\n```\n\n==order by 1表示根据第一列的值自然排序。==\n\n\n#### 自然连接\n\n要避免不要使用自然连接。\n\n### 条件逻辑\n\n- 根据cust_type_cd字段判断决定使用indiv_name还是business_name列的值：\n```\nselect c.cust_id, c.fed_id,\ncase \nwhen c.cust_type_cd = 'I' \nthen concat(i.fname, ' ', i.lname) \nwhen c.cust_type_cd = 'B' \nthen b.name \nelse 'Unknown' \nend name \nfrom customer c left outer join individual i \non c.cust_id = i.cust_id \nleft outer join business b \non c.cust_id = b.cust_id;\n```\n\n#### case表达式\n\n##### 查找型case表达式\n\n```\nCASE \n    WHEN C1 THEN E1 \n    WHEN C2 THEN E2 \n    ...\n    WHEN CN THEN CN \n    [ELSE ED] \nEND\n```\n\n上面的语句可以改为：\n```\nselect c.cust_id, c.fed_id,\ncase\n    when c.cust_type_cd = 'I' then \n    (select concat(i.fname, ' ', i.lname) \n    from individual i \n    where i.cust_id = c.cust_id) \n    when c.cust_type_cd = 'B' then \n    (select b.name \n    from business b \n    where b.cust_id = c.cust_id) \n    else 'Unknown' \n    end name \nfrom customer c;\n```\n\n##### 结果集变换\n```\nselect year(open_date) year, count(*) how_many \nfrom account \nwhere open_date > '1999-12-31' \nand open_date < '2006-01-01' \ngroup by year(open_date);\n```\n\n结果是6行，如果想要变换成单行6列：\n```\nselect \n    sum(case \n            when extract(year from open_date) = 2000 then 1 \n            else 0 \n        end) year_2000,\n    sum(case \n            when extract(year from open_date) = 2001 then 1 \n            else 0 \n        end) year_2001,\n    sum(case \n            when extract(year from open_date) = 2002 then 1 \n            else 0 \n        end) year_2002,\n    sum(case \n            when extract(year from open_date) = 2003 then 1 \n            else 0 \n        end) year_2003,\n    sum(case \n            when extract(year from open_date) = 2004 then 1 \n            else 0 \n        end) year_2004,\n    sum(case \n            when extract(year from open_date) = 2005 then 1 \n            else 0 \n        end) year_2005\nfrom account \nwhere open_date > '1999-12-31' and open_date < '2006-01-01';\n```\n        \n        \n##### 存在性检查\n\n```\nselect c.cust_id, c.fed_id, c.cust_type_cd,\n    case \n        when exists (select 1 from account a \n        where a.cust_id = c.cust_id \n        and a.product_cd = 'CHK') then 'Y' \n        else 'N' \n    end has_checking,\n    case\n        when exists (select 1 froom account a \n        where a.cust_id = c.cust_id \n        and a.product_cd = 'SAV') then 'Y' \n        else 'N' \n    end has_savings \nfrom customer c;\n```\n\n##### 除零错误\n\n```\nselect a.cust_id, a.product_cd, a.avail_balance / \n case\n  when prod_tots.tot_balance = 0 then 1 \n  else prod_tots.tot_balance \n end percent_of_total \nfrom account a inner join \n(select a.product_cd, sum(a.avail_balance) tot_balance \nfrom account a \ngroup by a.product_cd) prod_tots \non a.product_cd = prod_tots.product_cd;\n```\n\n### 事务\n\n#### 多用户数据库\n\n##### 锁\n\n两种锁……\n- ==写锁+读锁==\n- 写锁，读取不需要锁。服务器要保证从查询开始到结束读操作看到一个一致的数据视图，这个方法被称为==版本控制==。\n\n##### 锁的粒度\n\n- 表锁\n- 页锁（阻止多用户同时修改某表中同一页（一页通常是一段2～16KB的内存空间）的数据）\n- 行锁\n\n\n**显式启动事务**：\n- SQL Server\n```\nbegin transaction\n```\n- MySQL\n```\nstart transaction\n```\n\n**关闭自动提交：**\n- SQL Server\n\n```\nset implicit_transactions on\n```\n- MySQL\n```\nset autocommit=0\n```\n\n\n对于SQL Server和MySQL，默认自动提交模式，直到显示启动一个事务。\n\n一旦离开了自动提交模式，所有的SQL命令都会发生在同一个事务的范围，并且必须显式地对事务进行提交或回滚。\n\n##### 结束事务\n\n- commit\n- rollback\n\n除了提交commit或rollback指令，结束事务还可以有其他情景触发：\n- 服务器宕机\n- 提交一个SQL模式语句，比如alter table，这将会引起当前事务提交和一个新事务启动\n- 提交另一个start transaction命令，将会引起前一个事务提交\n- 因为服务器监测到一个死锁，并确定当前事务是罪魁祸首，服务器将会结束当前事务。这种情况下，事务将会被回滚，同时释放错误消息（大多数情况喜爱，终止的事务可以重启，如果没有再次遇到另一个死锁情况他将会成功）\n\n\n##### 事务保存点\n\n6.0版的MySQL包括以下存储引擎：\n- MyISAM    表级锁定的非事务引擎\n- MEMORY    内存表使用的非事务引擎\n- BDB       页级锁定的事务引擎\n- InnoDB    行级锁定的事务引擎\n- Merge     使多个相同的MyISAM看起来像一个单表（也叫表分割）的专用引擎\n- Maria     6.0.6版本中MyISAM的替代品，他添加了充分的恢复功能\n- Falcon    6.0.4版本起引入的采用行级锁定的高性能事务引擎\n- Archive   用于存储大量未检索数据的专用引擎，主要用来存档\n\n查看引擎：\n```\nshow table status like 'transaction' \\G\n```\n\n设置引擎：\n```\nalter table transaction engine = innodb;\n```\n\n\n- **创建保存点**\n\n```\nsavepoint my_savepoint;\n```\n\n- **回滚到保存点**\n\n```\nrollback to savepoint my_savepoint;\n```\n\n### 索引和约束\n\n\n#### 索引\n索引是一种以特定顺序保存的专用表。\n\n\n##### 创建索引\n\n```\nalter table department \nadd index dept_name_idx (name);\n```\n\n- 查看索引\n```\nshow index from department \\G\n```\n\n创建表时的包含一个约束，该约束将primary key dept_id列作为主关键字。\n\n- 删除索引\n```\nalter table department \ndrop index dept_name_idx;\n```\n\n- **唯一索引**\n\n\n设计数据库时，需要考虑哪些列能包含重复数据，哪些列不能。\n例如department表中不能出现两个相同名字的部门。可以通过department.name创建唯一索引限制出现重复部门名字。\n\n```\nalter table department \nadd unique dept_name_idx (name);\n```\n\n\n\n- **多列索引**\n\n```\nalter table employee \nadd index emp_names_idx (lname, fname);\n```\n\n\n创建多列索引时，必须考虑哪一列作为第一列，哪一列作为第二列，这样索引才会尽可能的有用。\n\n##### 索引类型\n\n- **B树索引**\n\n平衡树索引\n\nMySQL、Oracle、SQL Server默认都是B树索引。\n\n当向表中插入、更新和删除行时，服务器会尽力保持树的平衡。\n\n\n- **位图索引**\n\n位图索引通常应用于数据仓库环境，那里有大量数据被索引，那些列却只包含相对少的值（比如销售岗位、地理环境、产品、销售员）\n\n- **文本索引**\n\nMySQL、SQL Server   全文索引\nOracle              Oracle Text\n\n##### 如何使用索引\n\n```\nexplain select cust_id, sum(avail_balance) tot_bal \nfrom account \nwhere cust_id in (1,5,9,11) \ngroup by cust_id \\G\n```\n\n结果：\n```\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: account\n   partitions: NULL\n         type: index\npossible_keys: fk_a_cust_id\n          key: fk_a_cust_id\n      key_len: 4\n          ref: NULL\n         rows: 24\n     filtered: 33.33\n        Extra: Using where\n1 row in set, 1 warning (0.01 sec)\n```\n\n\n优化，给cust_id和avail_balance两列添加新索引：\n```\nalter table account \nadd index acc_bal_idx (cust_id, avail_balance);\n```\n\n再次查询优化器是如何处理的：\n```\nexplain select cust_id, sum(avail_balance) tot_bal \nfrom account \nwhere cust_id in (1,5,9,11) \ngroup by cust_id \\G\n```\n结果如下：\n```\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: account\n   partitions: NULL\n         type: range\npossible_keys: acc_bal_idx\n          key: acc_bal_idx\n      key_len: 4\n          ref: NULL\n         rows: 8\n     filtered: 100.00\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.01 sec)\n```\n\n- ==优化器使用了新索引，而不是fk_a_cust_id==\n- ==优化器预期只需要8行，而不是24行==\n- ==不需要account表即可满足查询结果（使用附加列的索引指定）==\n\n##### 索引的不足\n\n\n- 每个索引其实 都是一个表\n- 每次在对表添加或删除行时，表中的所有索引必须被修改，当更新行时，受到影响的列的任何索引也必须被修改。\n- 索引越多，服务器就需要做越多的工作来保持所有模式对象最新。\n\n\n默认策略：\n- ==确保所有的主键列被索引==（大部分服务器会在创建主键约束时自动生成唯一索引），针对多列主键，考虑为主键列的子集构建附加索引，或者以与主键约束定义不同的顺序为所有主键列另外生成索引\n- ==为所有被外键约束引用的列创建索引。== 服务器在准备删除父行时会查找以确保没有子行存在，为此他必须发出一个查询搜索列中的特定值，如果该列没有索引，那么服务器必须扫描整个表\n- ==索引那些被频繁检索的列。除了短字符串（3～50个字符）列，大多数日期列也是不错的候选==\n\n\n#### 约束\n\n- 主键约束\n- 外键约束\n- 唯一约束\n- 检查约束\n\n**创建约束**\n```sql\ncreate table product \n(product_cd varchar(10) not null,\nname varchar(50) not null,\nproduct_type_cd varchar(10) not null,\ndate_offered date,\ndate_retired date,\nconstraint fk_product_type_cd foreign key (product_type_cd) \nreferences product_type (product_type_cd) ,\nconstraint pk_product primary key (product_cd)\n);\n\n```\n\n\n##### 约束与索引\n\nMySQL 主键约束、外键约束和唯一约束时，都会生成索引。\n\n##### 级联约束\n\n\n- on updae cascade\n\n```sql\nalter table product \ndrop foreign key fk_product_type_cd;\n\nalter table product \nadd constraint fk_product_type_cd foreign key (product_type_cd) \nreferences product_type (product_type_cd) \non update cascade;\n```\n\n- on delete cascade\n\n```\nalter table product \nadd constraint fk_product_type_cd foreign key (product_type_cd) \nreferences product_type (product_type_cd) \non update cascade \non delete cascade;\n```\n\n\n### 视图\n\n创建视图\n```\ncreate view customer_vw \n(cust_id,\nfed_id,\ncust_type_cd,\naddress,\ncity,\nstate,\nzipcode\n)\nas\nselect cust_id,\nconcat('ends in ', substr(fed_id,8,4)) fed_id, \ncust_type_cd,\naddress,\ncity,\nstate,\npostal_code\nfrom customer;\n```\n使用视图\n```\nselect cust_id, fed_id, cust_type_cd \nfrom customer_vw;\n```\n\n服务器真正执行的查询是将两者合并创建的一个新查询：\n```\nselect cust_id,\nconcat(\"ends in \", substr(fed_id,8,4)) fed_id,\ncust_type_cd \nfrom customer;\n```\n\n查看视图有哪些列：\n```\ndescribe customer_vw;\n```\n\n\n```\nselect cst.cust_id, cst.fed_id, bus.name \nfrom customer_vw cst inner join business bus \non cst.cust_id = bus.cust_id;\n```\n\n#### 为什么使用视图\n\n##### 数据安全\n\n只能查询企业用户：\n```\ncreate view business_customer_vw \n(cust_id,\nfed_id,\ncust_type_cd,\naddress,\ncity,\nstate,\nzipcode\n) \nas \nselect cust_id,\nconcat('ends in ', substr(fed_id, 8, 4)) fed_id,\ncust_type_cd,\naddress,\ncity,\nstate,\npostal_code \nfrom customer \nwhere cust_type_cd = 'B';\n```\n\n\n##### 数据聚合\n\n生成报表展示账户数据和每个客户的储蓄总额：\n```\ncreate view customer_totals_vw \n(cust_id,\ncust_type_cd,\ncust_name,\nnum_accounts,\ntot_deposits) \nas \nselect cst.cust_id, cst.cust_type_cd,\n case \n  when cst.cust_type_cd = 'B' then \n  (select bus.name from business bus where bus.cust_id = cst.cust_id) \n  else \n  (select concat(ind.fname, ' ', ind.lname) \n  from individual ind \n  where ind.cust_id = cst.cust_id) \n end cust_name,\n sum(case when act.status = 'ACTIVE' then 1 else 0 end) tot_active_accounts,\n sum(case when act.status = 'ACTIVE' then act.avail_balance else 0 end) tot_balance \nfrom customer cst inner join account act \non act.cust_id = cst.cust_id \ngroup by cst.cust_id, cst.cust_type_cd;\n```\n\n决定将数据预聚合到一个表中而不是利用视图总计，那么可以先创建customer_totals表，然后修改视图customer_totals_vw定义，再从该表中检索数据。\n```\ncreate table customer_totals  \nas \nselect * from customer_totals_vw;\n```\n\n```\ncreate or replace view customer_totals_vw \n(cust_id,\ncust_type_cd,\ncust_name,\nnum_accounts,\ntot_deposits\n) \nas \nselect cust_id, cust_type_cd, cust_name, num_accounts, tot_deposits \nfrom customer_totals;\n```\n\n##### 隐藏复杂性\n\n##### 连接分区数据\n\ntransaction变的越来越大，那么设计者可以将其分为两个表：transaction_current,transaction_historic。然后可以通过视图将两个表联合起来：\n```\ncreate view transaction_vw \n(txn_date,\naccount_id,\ntxn_type_cd,\namount,\nteller_emp_id,\nexecution_branch_id,\nfunds_avail_date\n) \nas \nselect txn_date, account_id, txn_type_cd, amount, teller_emp_id, \nexecution_branch_id, funds_avail_date \nfrom transaction_historic \nunion all \nselect txn_date, account_id, txn_type_cd, amount, teller_emp_id, \nexecution_branch_id, funds_avail_date \nfrom transaction_current;\n```\n\n\n#### 可更新的视图\n\n对于MySQL，如果以下条件能满足，那么视图就是可更新的：\n- 没有使用聚合函数，例如max()、min()、avg() 等\n- 视图没有使用group by或having子句\n- select或from子句中不存在子查询，并且where子句中的任何子查询都不引用from子句中的表\n- 视图没有使用union、union all和distinct\n- from子句包括不止一个表或可更新视图\n- 如果有不止一个表或视图，那么from子句只使用内连接\n\n修改视图：\n```\nupdate customer_vw \nset city = 'Woooburn' \nwhere city =  'Woburn';\n```\n\n\n### 元数据\n\n- 元数据——数据的数据\n- 数据字典或者系统目录\n\n\n#### 信息模式\n\n- ==information_schema数据库==里所有可用对象是视图\n\n检索bank数据库里所有表的名字：\n```\nselect table_name, table_type \nfrom information_schema.tables \nwhere table_schema = 'bank' \norder by 1;\n```\n\n在结果中排除视图：\n```\nselect table_name, table_type \nfrom information_schema.tables \nwhere table_schema = 'bank' and table_type = 'BASE TABLE' \norder by 1;\n```\n\n只检索视图：\n```\nselect table_name,is_updatable \nfrom information_schema.views \nwhere table_schema='bank' \norder by 1;\n```\n\n\n查看表的信息：\n```\nselect column_name,data_type,character_maximum_length char_max_len,\nnumeric_precision num_prcsn, numeric_scale num_scale \nfrom infromation_schema.columns \nwhere table_schema='bank' and table_name='account' \norder by ordinal_position;\n```\n\n\n查询表中的索引信息：\n```\nselect index_name,non_unique,seq_in_index,column_name \nfrom information_schema.statistics \nwhere table_schema = 'bank' and table_name = 'account' \norder by 1,3;\n```\n\n查询bank模式中的所有视图：\n```\nselect constraint_name,table_name,constraint_type \nfrom information_schema.table_constraints \nwhere table_schema = 'bank' \norder by 3,1;\n```\n\n#### 使用元数据\n\n##### 模式生成脚本\n\n##### 生成动态SQL\n\nMySQL为动态SQL执行提供了：\n- prepare\n- execute\n- deallocate\n语句\n\n\n```\n--将sql语句赋给变量qry\nset @qry = 'select cust_id, cust_type_cd, fed_id from customer';\n\n-- qry被prepare语句提交给数据库引擎（解析、安全检查、优化）\nprepare dynsql1 from @qry;\n\n-- 执行\nexecute dynsql1;\n\n-- deallocate prepare关闭语句，释放执行中使用的所有数据库资源（如游标）\ndeallocate prepare dynsql1;\n\n```\n\n\n\n```\n-- 查询包含占位符\nset @qry = 'select product_cd, name, product_type_cd, date_offered, date_retired from product where product_cd = ?';\n\nprepare dynsql2 from @qry;\n\nset @prodcd = 'CKH';\n\nexecute dynsql2 using @prodcd;\n\nset @prodcd = 'SAV';\n\nexecute dynsql2 usging @prodcd;\n\ndeallocate prepare dynsql2;\n\n```\n\n可以通过使用元数据生成动态SQL查询语句，而不是使用上面的硬编码。\n\n\n### MySQL对SQL语言的扩展\n\n#### limit子句\n\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \nlimit 3;\n```\n\n\n- 组合limit子句和order by子句\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \norder by how_many desc \nlimit 3;\n```\n\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \norder by how_many desc \nlimit 2,1;\n```\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \norder by how_many desc \nlimit 2,999999999;\n```\n\n\n##### into outfile子句\n\n```\nselect emp_id, fname, lname, start_date \ninto outfile 'C:\\\\TEMP||emp_list.txt' \nfrom employee;\n```\n默认列间用制表符（'\\t'）隔开，记录间用换行符（'\\n'）隔开。\n\n- 改成用字符 '|'隔开\n```\nselect emp_id, fname, lname, start_date \ninto outfile 'C:\\\\TEMP||emp_list.txt' \nfields terminated by '|' \nlines terminated by '@' \nfrom employee;\n```\n\n\n##### 组合insert/update语句\n\n更新插入（upsert）\n\n```\ninsert into branch_usage (branch_id, cust_id, last_visited_on) \nvalues (1,5, current_timestamp()) \non duplicate key update last_visited_on = current_timestamp();\n```\n\n\n##### 多表更新与删除\n\n同时删除account、customer、individual表中的某一个客户数据\n\n```\ndelete account2, customer2, individual2 \nfrom account2 inner join customer2 \non account2.cust_id=customer2.cust_id \ninner join individual2 \non customer2.cust_id = individual2.cust_id \nwhere individual2.cust_id = 1;\n```\n\n\n\n\n\n\n\n\n","source":"_posts/《SQL学习指南》笔记.md","raw":"---\ntitle: 《SQL学习指南》笔记\ndate: 2018-12-15 19:14:45\ntags: SQL\ntoc: true\n---\n\n\n### 创建和使用数据库\n\n- 主键约束\n`constraint pk_person primary key (person_id)`\n\n- 检查约束\n`gender char(1) check (gender in ('M','F')),`\n\n或用`gender ENUM('M','F'),`代替检查约束\n\n<!--more-->\n\n\n```sql\n create table person\n (person_id smallint unsigned,\n fname varchar(20),\n lname varchar(20),\n gender enum('M','F'),\n birth_date date,\n street varchar(30),\n city varchar(20),\n state varchar(20),\n country varchar(20),\n postal_code varchar(20),\n constraint pk_person primary key (person_id)\n );\n```\n\n\n\n```sql\ncreate table favorite_food\n(person_id smallint unsigned,\nfood varchar(20),\nconstraint pk_favorite_food primary key (person_id, food),\nconstraint fk_fav_food_person_id foreign key (person_id)\nreferences person (person_id)\n);\n```\n\n**此时想要给person表主键增加auto_incremnt**\n```\nalter table person modify person_id smallint unsigned auto_increment;\n```\n报错，\n```\nError Code: 1833. Cannot change column 'person_id': used in a foreign key constraint 'fk_fav_food_person_id' of table 'table.favorite_food'\n```\n，因为被用在favorite_food表中作为外键了，不允许修改，\n\n==Solution 1==：\n\n```\nlock tables \nfavorite_food write,\nperson write;\n```\n```\nalter table favorite_food \ndrop foreign key fk_fav_food_person_id,\nmodify person_id smallint unsigned;\n```\n然后再修改person主键\n```\nalter table person modify person_id smallint unsigned auto_increment;\n```\n\n创建外键\n```\nalter table favorite_food \nadd constraint fk_fav_food_person_id foreign key (person_id) \nreferences person (person_id);\n```\n```\nunlock tables;\n```\n\n==solution 2==\n\nYou can turn off foreign key checks:\n\n\n```\nSET FOREIGN_KEY_CHECKS = 0;\n\n/* DO WHAT YOU NEED HERE */\n\nSET FOREIGN_KEY_CHECKS = 1;\n```\n\n插入一条数据\n```\ninsert into person \n(person_id, fname, lname,gender,birth_date) \nvalues (null, 'William', 'Turner','M','1972-05-27');\n```\n\n```\ninsert into favorite_food (person_id,food) \nvalues (1, 'pizza');\ninsert into favorite_food (person_id,food) \nvalues (1, 'cookies');\ninsert into favorite_food (person_id,food) \nvalues (1, 'nachos');\n```\n\n更新数据\n```\nupdate person \nset street='1225 Tremont St.',\ncity='Boston',\nstate='MA',\ncountry='USA',\npostal_code='02138' \nwhere person_id=1;\n```\n\n删除数据\n```\ndelete from person \nwhere person_id=2;\n```\n\n\n### 查询\n\n```\nselect emp_id \n'ACTIVE',\nemp_id * 3.14159,\nUPPER(lname) \nfrom employee;\n```\n\n执行内建函数或对简单的表达式求值可以完全省略from子句：\n```\nselect version(),\nuser(),\ndatabase();\n```\n\n#### 列的别名：\n\n```\nselect emp_id,\n'ACTIVE' status,\nemp_id * 3.14159 empid_x_pi,\nUPPER(lname) last_name_upper \nfrom employee;\n```\n\n(可以在别名前加上AS关键字)\n\n\n#### 去除重复的行\n\n```\nselect distinct cust_id \nfrom account;\n```\n\n==注：产生无重复的结果集需要首先对数据排序，因此，不要为了确保去重二使用DiSTINCT，而应先了解所使用的数据是否可能包含重复的行。==\n\n\n#### from子句\n\nfrom子句定义了查询中所使用的表，以及连接这些表的方式。\n\n- 表\n    - 永久表（create table语句创建的表）\n    - 临时表（子查询返回的表）\n    - 虚拟表（create view）\n\n通过别名e来引用子查询：\n```\nselect e.emp_id, e.fname, e.lname \nfrom (select emp_id,fname,lname,start_date,title \nfrom employee) e;\n```\n\n视图是存储在数据字典中的查询，它的行为表现的像一个表，但实际上并不拥有任何数据（因此称为虚拟表）。当发出一个对视图的查询时，该查询会被绑定到视图定义上，以产生最终被执行的查询。\n\n1. 定义一个查询employee表的视图\n\n```\ncreate view employee_vw AS \nselect emp_id, fname, lname, \nYEAE(start_date) start_year \nfrom employee;\n```\n\n2. 查询视图\n\n```\nselect emp_id, start_year \nfrom employee_vw;\n```\n\n##### 表连接\n\n```\nselect employee.emp_id,employee.fname,employee.lname,\ndepartment.name dept_name \nfrom employee inner join department \non employee.dept_id=department.dept_id;\n```\n\n##### 定义表别名\n\n```\nselect e.emp_id,e.fname,e.lname,\nd.name dept_name \nfrom employee e inner join department d \non e.dept_id=d.dept_id;\n```\n\n#### where子句\n\n```\nselect emp_id,fname,lname,start_date,title \nfrom employee \nwhere title='Head Teller' \nAND start_date > '2006-01-01';\n```\n\n\n#### group by和having子句\n\n```\nselect d.name,count(e.emp_id) num_employees \nfrom department d inner join employee e \non d.dept_id=e.dept_id \ngroup by d.name \nhaving count(e.emp_id) > 2;\n```\n\n#### order by\n\n```\nselect open_emp_id, product_id \nfrom account \norder by open_emp_id;\n```\n\n- 升序（ASC、默认）\n- 降序DESC\n\n##### 根据表达式排序\n\n使用right()内建函数提取fed_id列的最后三个字符排序：\n\n```\nselect cust_id,cust_type_cd,city,state,fed_id \nfrom customer \norder by right(fed_id, 3);\n```\n\n##### 根据数字占位符排序\n\n根据查询返回的第2，5列排序： \n```\nselect emp_id,title,start_date,fname.lname \nfrom employee \norder by 2,5;\n```\n\n### 过滤\n\n#### 条件类型\n\n\n```\nselect pt.name product_type,p.name product \nfrom product p inner join product_type pt \non p.product_type_cd = pt.product_type_cd \nwhere pt.name = 'Customer Accounts';\n```\n\n不等条件：\n```\nselect pt.name product_type,p.name product \nfrom product p inner join product_type pt \non p.product_type_cd = pt.product_type_cd \nwhere pt.name <> 'Customer Accounts';\n```\n\n描述不等条件时，可以用`<>`也可以用`!=`\n\n\n##### 范围条件\n\n```\nselect emp_id,fname,lname,start_date \nfrom employee \nwhere start_date<'2007-01-01';\n```\n\n```\nselect emp_id,fname,lname,start_date \nfrom employee \nwhere start_date <'2007-01-01' \nand start_date >= '2005-01-01';\n```\n\nbetween(两端都是包含)\n\n```\nselect emp_id,fname,lname,start_date \nfrom employee \nwhere start_date between '2005-01-01' and '2006-12-31';\n```\n\n```\nselect cust_id,fed_id \nfrom customer \nwhere cust_type_cd='I'\nand fed_id between '500-00-0000' and '999-99-9999';\n```\n\nin操作符\n\n```\nselect account_id,product_id,cust_id,avail_balance \nfrom account \nwhere product_cd in ('CHK','SAV','CD,'MM');\n```\n\n```\nselect account_id,product_id,cust_id,avail_balance \nfrom account \nwhere product_cd in (select product_cd from product \nwhere product_type_cd = 'ACCOUNT');\n```\n\n\nnot in\n```\nselect account_id,product_cd,cust_id,avail_balance \nfrom account \nwhere product_cd not in ('CHK','SAV','CD','MM');\n```\n\n##### 匹配条件\n\n```\nselect emp_id,fname,lname \nfrom employee \nwhere left(lname,1)='T';\n```\n\n可以使用内建函数left()，但更好的做法是使用通配符：\n```\nselect lname \nfrom employee \nwhere lname like '_a%e%';\n```\n\n```\nselect cust_id,fed_id \nfrom customer \nwhere fed_id like '___-__-____';\n\n```\n\n```\nselect emp_id,fname,lname \nfrom employee\nwhere lname like 'F%' or lname like 'G%';\n```\n\n##### 正则表达式\n\n```\nselect emp_id,fname,lname \nfrom employee \nwhere lname regexp '^[FG]';\n```\n\n#### NULL\n\n```\nselect emp_id,fname,lname,superior_emp_id \nfrom employee \nwhere superior_emp_id is NULL;\n```\n\n### 多表查询\n\n##### 笛卡尔积\n\n交叉连接\n\n```\nselect e.fname,e.lname,d.name \nfrom employee e join department d;\n```\n\n##### 内连接\n\n如果在一个表中的dept_id列中存在某个值，但该值在另一张表的dept_id列中不存在，那么相关行的连接会失败，在结果集中将会排除包含该值的行。\n\n```\nselect e.fname,e.lname,d.name \nfrom employee e join department d \non e.dept_id = d.dept_id;\n```\n\n- 上面没加inner关键字，默认使用inner，但最好加上。\n- 如果连接两个表的列名是相同的，可以使用using子句代替on子句：\n\n```\nselect e.fname,e.lname,d.name \nfrom employee e inner join department d \nusing (dept_id);\n```\n\n\n#### 连接3个或更多的表\n\n```\nselect a.account_id,c.fed_id,e.fname,e.lname \nfrom account a inner join customer c \non a.cust_id=c.cust_id \ninner join employee e \non a.open_emp_id = e.emp_id \nwhere c.cust_type_cd = 'B';\n```\n\n\n\n##### 将子查询结果作为查询表\n\n```\nselect a.account_id,a.cust_id,a.open_date,a.product_cd \nfrom account a INNER JOIN \n    (select emp_id,assigned_branch_id \n    from employee \n    where start_date < '2007-01-01' \n    and (title = 'Teller' OR title = 'Head Teller')) e\n    ON a.open_emp_id = e.emp_id \n    INNER JOIN\n        (select branch_id \n        from branch \n        where name = 'Woburn Branch') b \n        ON e.assigned_branch_id = b.branch_id;\n```\n\n##### 连续两次使用同一个表\n\n需要给每个branch表的实例定义不用的别名\n\n```\nselect a.account_id,e.emp_id,\nb_a.name open_branch,b_e.name emp_branch \nfrom account a inner join branch b_a \non a.open_branch_id=b_a.branch_id \ninner join employee e \non a.open_emp_id=e.emp_id \ninner join branch b_e \non e.assigned_branch_id=b_e.branch_id \nwhere a.product_cd='CHK';\n```\n\n#### 自连接\n\n```\nselect e.fname,e.lname \ne_mgr.fname mgr_fname,e_mgr.lname mgr_lname \nfrom employee e inner join employee e_mgr \non e.superior_emp_id = e_mgr.emp_id;\n```\n\n上面语句列出了雇员姓名和主管姓名，但是employee表中一共有18行，但此查询只返回17行，这是由于银行的总经理并没有自己的主管（superior_emp_id列为null），因此在该行连接失败了。为了在结果集中包含这个数据，应使用外连接。\n\n\n```\nselect e1.fname, e1.lname, 'VS' vs, e2.fname, e2.lname \nfrom employee e1 inner join employee e2 \non e1.emp_id < e2.emp_id \nwhere e1.title='Teller' and e2.title = 'Teller';\n```\n\n#### 连接条件和过滤条件\n\n```\nselect a.account_id, a.product_cd, c.fed_id \nfrom account a inner join customer c \non a.cust_id = c.cust_id \nwhere c.cust_type_cd = 'B';\n```\n\n\n### 使用集合\n\n- 当对两个数据集合执行集合操作时，必须满足：\n    - 两个数据集合必须具有同样数目的列\n    - 两个数据集中对应列的数据类型必须是一样的（或者服务器能偶从一种转换成另一种）\n\n```\nselect 1 num, 'abc' str \nunion \nselect 9 num, 'xyz' str;\n```\n\n\n##### union操作符\n\nunion对连接后的集合排序并去除重复项，而union all保留重复项。\n\n```\nselect 'IND' type_cd, cust_id, lname name \nfrom individual \nunion all \nselect 'BUS' type_cd, cust_id, name \nfrom business;\n```\n\n\n返回重复数据：\n\n```\nselect emp_id \nfrom employee \nwhere assigned_branch_id=2 \nand (title='Teller' or title='Head Teller') \nunion all \nselect distinct open_emp_id \nfrom account \nwhere open_branch_id = 2;\n```\n\n查询结果含有重复项，如果要排除重复项，需要把union all改成union\n\n\n##### intersect 操作符\n\n\nintersect 查找交集，并且去除了交集区域中所有重复的行，不删除重复的的是intersect all操作符\n\n```\nselect emp_id \nfrom employee \nwhere assigned_branch_id=2 \nand (title='Teller' or title='Head Teller') \nintersect  \nselect distinct open_emp_id \nfrom account \nwhere open_branch_id = 2;\n```\n\n##### except操作符\n\nexcept操作符返回第一个表减去第二个表重合的元素后剩下的部分。\nexcept在集合A中去除所有的重复数据，而except all则根据重复数据在集合B中出现的次数进行删除。\n\n```\nselect emp_id \nfrom employee \nwhere assigned_branch_id=2 \nand (title='Teller' or title='Head Teller') \nexcept   \nselect distinct open_emp_id \nfrom account \nwhere open_branch_id = 2;\n```\n\n\n##### 集合操作符优先级\n\n```\nselect cust_id \nfrom account \nwhere product_cd in ('SAV','MM') \nunion all \nselect a.cust_id \nfrom account a inner join branch b \non a.open_branch_id = b.branch_id \nwhere b.name = 'Woburn Branch' \nunion \nselect cust_id \nfrom account \nwhere avail_balance between 500 and 2500;\n```\n\n复合查询包含3个或3个以上的查询语句，他们是自顶向下的顺序解析和执行的，但要注意：\n\n- 在调用集合操作时，intersect操作符比其他操作符具有更高的优先级\n- 可以用圆括号对多个查询进行封装，以明确指定他们的指定次序\n\nMySQL 没有实现intersect操作符\n\n### 数据生成、转换和操作\n\n#### 使用字符串数据\n\n- `CHAR`\n    - 固定长度，不足部分使用空格填充的字符串\n    - MySQL的CHAR类型的长度为255字节。\n    - Oracle为2000\n    - SQL Server 8000\n- `varchar`\n    - 变长字符串。\n    - MySQL允许的varchar列最多包含65536个字符\n    - Oracle为4000\n    - SQL Server为8000\n- `text`(MySQL和SQL Server) 或 `CLOB`(Character Large Object; Oracle)\n    - MySQL有多种text类型，最多4GB\n    - SQL只有text，最长2GB\n    - Oracle的CLOB，最大128TB\n\n\n```\ncreate table string_tbl\n(char_fld CHAR(30),\nvchar_fld varchar(30),\ntext_fld text);\n```\n\n##### 生成字符串\n\nMySQL 6.0中，默认行为是“strict”模式，发生问题时抛出异常，而在早先的服务器版本中，默认方式是截断字符串并发出一个警告。如果希望数据库引擎采取后一种方式，可以将之修改为ANSI模式。\n\n- 查看数据库当前模式\n\n```\nselect @@session.sql_mode;\n```\n\n- 改变当前模式\n\n```\nset sql_mode='ansi';\n```\n\n==由于服务器是在纯粹字符串时按需分配空间，因此不会因为将varchar列的上限值设的比较大而浪费资源。==\n\n- 单引号转义符\n\n```\nupdate string_tb1 set text_fld='This string didn''t work, but it does now';\n```\n\n可以使用单引号作为转义符\n\n```\nupdate string_tb1 set text_fld='This string didn\\'t work, but it does now';\n```\n\n- 使用内建函数quote()，他用单引号将整个字符串包含起来，并为字符串本身的单引号/撇号增加转义符：\n```\nselect quote(text_fld) \nfrom string_tbl;\n```\n\n- 包含特殊字符 \n```\nselect 'abcdefg', CHAR(97,98,99,100,101,102,103);\n```\n\n```\nselect CHAR(138,139,140,141,142,143,144,145,146,147);\n```\n\n```\nselect concat('danke sch', char(148), 'n');\n```\n\n字符串长度：\n```\nselect length(char_fld) char_length,\nlength(vchar_fld) varchar_length,\nlength(text_fld) text_length \nfrom string_tbl;\n```\n\n字符串位置：\n```\nselect position('characters' in vchar_fld) \nfrom string_tbl;\n```\n\n如果找不到该子字符串，那么position()函数将返回0.\n\n\n从任意位置开始查找字符串位置：\n\n```\nselect locate('is', vchar_fld, 5) \nfroom string_tbl;\n```\n\n字符串比较（只有mysql）\n\nmysql的strcmp()大小写不敏感\n\n```\nselect strcmp('12345', 'abc') 12345_abc,\nstrcmp('abcd', 'xyz') abcd_xyz,\nstrcmp('qrstuv', 'QRSTUV') qrstuv_QRSTUV;\n```\n\n- like\n```\nselect name,name like '%ns' ends_in_ns \nfrom department;\n```\n\n```\nselect cust_id, cust_type_cd, fed_id, \nfed_id regexp '_{3}-_{2}-_{4}' is_ss_no_format \nfrom customer;\n```\n\n- concat()\n```\nupdate string_tbl \nset text_fld = concat(text_fld, ', but now it is longer');\n```\n\nOracle下，可以使用连接操作符`||`代替concat()进行字符串连接\nSQL Server并么有concat()函数，使用的是连接操作符`+`\n\n- 插入字符串 insert()\n```\nselect insert('goodbye world', 9, 0, 'cruel ') string;\n```\n\n如果第三个参数大于0，那么相应数目的字符将会被替换字符串所取代：\n\n```\nselect insert('goodbye world', 1, 7, 'hello') string;\n```\n\nOracle数据没有提供MySQL中的insert()类似函数，但他的replace()函数也可以用于替换字符串：\n\n```\nselect replace('goodbye world', 'goodbye', 'hello') from dual;\n```\n\nSQL Server 同样包含replace()函数，除此之外，还包含stuff()函数：\n```\nselect stuff('hello world', 1, 5, 'goodbye cruel');\n```\n\n- 子串 substring()\n```\nselect substring('goodbye cruel world', 9, 5);\n```\n\n#### 使用数值数据\n\n```\nselect (37 * 59) / (78 - (8 * 6));\n```\n\n```\nselect mod(10,4);\n\nselect pow(2, 8);\n\n\n```\n\n##### 控制数字经度\n\n- ceil()\n- floor()\n- round() 四舍五入，保留n位小数\n- truncate() 直接舍掉后面的\n```\nselect ceil(72.445),floor(72.445);\n```\n\n结果:`73    72`\n\n```\nselect round(72.4999),round(72.5);\n\nselect round(72.0909, 1), round(72.0909,2), round(72.0909, 3);\n```\n\n```\nselect truncate(72.0909,1), truncate(72.0909,2), truncate(72.0909,3);\n```\n\ntruncate()和round()第二个参数都可以指定为负数：\n```\nselect round(17, -1), truncate(17, -1);\n```\n\n结果：\n`20  10`\n\n##### 处理有符号数\n\n```\nselect account_id, sign(avail_balance), abs(avail_balance) \nfrom account;\n```\n\n- sign()函数取符号\n- abs()函数取绝对值\n\n#### 使用时间数据\n\n- 时区设置：全局时区和会话时区\n\n```\nselect @@global.time_zone,@@session.time_zone;\n```\n\n服务器自动将字符串适配到datetime列：\n```\nupdate transaction \nset txn_date = '2008-09-17 15:30:00' \nwhere txn_id = 99999;\n```\n\n使用cast()函数转换\n\n```\nselect cast('2008-09-17 15:30:00' as datetime);\n\nselect cast('2009-09-17' as date) date_field \nselect cast('108:17:57' as time) time_field;\n```\n\n\n\n- `str_to_date()`函数  将字符串格式化为日期\n```\nupdate individual \nset birth_date = str_to_date('September 17, 2008', '%M %d, %Y') \nwhere cust_id = 9999;\n```\n\n- 当前日期\n```\nselect current_date(), current_time(), current_timestamp();\n```\n\n- 当前日期加上5天 `date_add()`\n```\nselect date_add(current_date(), interval 5 day);\n```\n\n```\nupdate transaction \nset txn_date = date_add(txn_date, interval '3:27:11' hour_second) \nwhere txn_id = 9999;\n```\n\n- 当月最后一天  `last_day()`\n```\nselect last_day('2008-09-17');\n```\n\n\n- 返回某一天是星期几 `dayname()`\n```\nselect dayname('2008-09-18');\n```\n- 提取日期值中的信息 `extract()`函数\n```\nselect extract(year from '2008-09-18 22:19:05');\n```\n\n- 时间间隔 `datediff()`\n```\nselect datediff('2009-09-03', '2009-06-24');\n```\n\n\n#### 转换函数\n\n- `cast()`\n\n```\nselect cast('14567' as signed integer);\n```\n\n遇到非数字的字符，转换将中止并不返回错误：\n```\nselct cast('999ABC111' as unsigned integer);\n```\n\n### 分组与聚集\n\n- group by\n\n- 分组\n```\nselect open_emp_id \nfrom account \ngroup by open_emp_id;\n```\n\n- 分组，并查看每一个分组的数量\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id;\n```\n\n- 过滤出条数大于4的分组，需要用having，不能用where，因为用where过滤的时候，还未分组\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \nhaving count(*) > 4;\n```\n#### 聚集函数\n\n- Max()\n- Min()\n- Avg()\n- Sum()\n- Count()\n\n##### 隐式或显式分组\n\n```\nselect max(avail_balance) max_balance,\nmin(avail_balance) min_balance,\navg(avail_balance) avg_balance,\nsum(avail_balance) sum_balance,\ncount(*) num_accounts \nfrom account \nwhere product_cd = 'CHK';\n```\n\n上个例子中，查询返回的每个值都是由聚集函数产生的，这些聚集函数作用于使用过滤条件product_cd='CHK'指定的分组上的所有行。这里没有使用group by子句，因此它是一个隐式分组（即包含查询返回的所有行）。\n\n但如果同时需要提取product_cd列，如下：\n```\nselect product_cd,\nmax(avail_balance) max_balance,\nmin(avail_balance) min_balance,\navg(avail_balance) avg_balance,\nsum(avail_balance) sum_balance,\ncount(*) num_accounts \nfrom account;\n```\n\n将会报错，因为没有显式地指定如何对数据分组。改为：\n```\nselect product_cd,\nmax(avail_balance) max_balance,\nmin(avail_balance) min_balance,\navg(avail_balance) avg_balance,\nsum(avail_balance) sum_balance,\ncount(*) num_accounts \nfrom account \ngroup by product_cd;\n```\n\n\n##### 对独立值计数\n\n```\nselect count(open_emp_id)\nfrom account;\n```\n\n去除重复的行统计：\n```\nselect count(distinct open_emp_id) \nfrom account;\n```\n\n##### 对null的计算\n\ncount(*) 计算所有行\ncount(val) 会忽略null\n\n#### 产生分组\n##### 单列分组\n\n```\nselect product_cd, sum(avail_balance) prod_balance \nfrom account \ngroup by product_cd;\n```\n\n##### 对多列的分组\n```\nselect product_cd,open_branch_id, \nsum(avail_balance) tot_balance \nfrom account \ngroup by product_cd, open_branch_id;\n```\n\n##### 利用表达式分组\n\n```\nselect extract(year form start_date) year,\ncount(*) how_many \nfrom employee \ngroup by extract(year from start_date);\n```\n\n##### 产生合计数 with rollup\n\n- 独立产品也进行合计，最后还会产生总的合计\n\n```\nselect product_cd, open_branch_id,\nsum(avail_balance) tot_balance \nfrom account \ngroup by product_cd, open_branch_id with rollup;\n```\n\n#### 分组过滤条件\n\n- 分组前——用where过滤\n- 分组后——用having过滤\n \n```\nselect product_cd, sum(avail_balance) prod_balance \nfrom account \nwhere status = 'ACTIVE' \ngroup by product_cd \nhaving sum(avail_balance) >=10000;\n```\n\n### 子查询\n\n```\nselect account_id,product_id,cust_id,avail_balance \nfrom account \nwhere open_emp_id <> (select e.emp_id \nfrom employee e inner join branch b \non e.assigned_branch_id = b.branch_id \nwhere e.title = 'Head Teller' and b.city = 'Woburn');\n```\n\n上述子查询只有一个结果，否则会报错。\n\n#####  多行单列子查询\n- in 和 not in运算分\n```\nselect branch_id, name, city \nfrom branch \nwhere name in ('Headquarters', 'Quincy Branch');\n```\n\n查询所有主管：\n```\nselect emp_id, fname, lname, title \nfrom employee \nwhere emp_id in (select superior_emp_id \nfrom employee);\n```\n\n查询所有不管理别人的雇员：\n\n```\nselect emp_id, fname, lname, title \nfrom employee \nwhere emp_id not in (select superior_emp_id \nfrom employee \nwhere superior_emp_id is not null);\n```\n\n- all运算符 \n将某单值与集合中的每个值进行比较：\n\n 查询非主管雇员：\n```\nselect emp_id, fname, lname, title \nfrom employee \nwhere emp_id <> all (select superior_emp_id \nfrom employee \nwhere superior_emp_id is not null);\n```\n\n==当使用not in或<>运算符比较一个值和一个值集时，必须确保值集中不包含null值，因为服务器将表达式左边的值与null比较时，都将产生未知的结果。==\n\n\n\n- any运算符\n\nany运算符只要有一个比较成立，则条件为真。all需要都成立才为真。\n\n```\nselect account_id,cust_id,product_cd, avail_balance \nfrom account \nwhere avail_balance > any (select a.avail_balance \nfrom account a inner join individual i \non a.cust_id = i.cust_id \nwhere i.fname = 'Frank' and i.lname = 'Tucker');\n```\n\n\n##### 多列子查询\n\n- 多重单列子查询：\n```\nselect account_id, product_id, cust_id \nfrom account \nwhere open_branch_id = (select branch_id \nfrom branch \nwhere name = 'Woburn Branch') \nand open_emp_id in (select emp_id \nfrom employee \nwhere title = 'Teller' or title = 'Head Teller');\n```\n\n等同于下面的 多列子查询：\n```\nselect account_id, product_id, cust_id \nfrom account \nwhere (open_branch_id, open_emp_id) in \n(select b.branch_id, e.emp_id \nfrom branch b inner join employee e \non b.branch_id = e.assigned_branch_id \nwhere b.name = 'Woburn Branch' \nand (e.title = 'Teller' or e.title = 'Head Teller'));\n```\n\n#### 关联子查询\n\n子查询最后引用的c.cust_id使之具有关联性，这样他的执行必须依赖于包含查询提供的c.cust_id。\n```\nselect c.cust_id, c.cust_type_cd, c.city \nfrom customer c \nwhere 2 = (select count(*) \nfrom account a \nwhere a.cust_id = c.cust_id);\n```\n\n```\nselect c.cust_id, c.cust_type_cd, c.city\nfrom customer c \nwhere (select sum(a.avail_balance) \nfrom account a \nwhere a.cust_id = c.cust_id)\nbetween 5000 and 10000;\n```\n\n\n```\nselect 'ALTER! : Account #1 Hs Incorrect Balance!' \nfrom account \nwhere (avail_balance, pending_balance) <> ¡™\n(select sum(<expression to generate available balance>), \nsum(<expression to generate pending balance>) \nfrom transaction \nwhere account_id = 1) \nand account_id = 1;\n```\n\n对于上面的例子，用关联子查询代替非关联子查询，升级为：\n```\nselect 'ALTER! : Account #1 Hs Incorrect Balance!' \nfrom account t \nwhere (avail_balance, pending_balance) <> \n(select sum(<expression to generate available balance>), \nsum(<expression to generate pending balance>) \nfrom transaction t \nwhere t.account_id = a.account_id);\n```\n\n##### exists 运算符\n\nexists运算符是构造包含关联子查询条件最常用的运算符。\n\n```\nselect a.account_id, a.product_cd, a.cust_id, a.avail_balance \nfrom account a \nwhere exists (select 1 \nfrom transaction t \nwhere t.account_id = a.account_id \nand t.txn_date = '2008-09-22');\n```\n\n- not exists\n\n```\nselect a.account_id, a.product_cd, a.cust_id \nfrom account a \nwhere not exists (select 1 \nfrom business b \nwhere b.cust_id = a.cust_id);\n```\n##### 关联子查询操作数据\n\n```\nupdate account a \nset a.last_activity_date = \n(select max(t.txn_date) \nfrom transaction t \nwhere t.account_id = a.account_id);\n```\n\n但是上面的子查询语句没有检查每个账户是否发生过交易，否则有可能为null，因此修改为：\n```\nupdate account a \nset a.last_activity_date = \n(select max(t.txn_date) \nfrom transaction t \nwhere t.account_id = a.account_id) \nwhere exists (select 1 \nfrom transaction t \nwhere t.account_id = a.account_id);\n```\n\n删除没有员工的部门：\n\n```\ndelete from department \nwhere not exists (select 1 \nfrom employee \nwhere employee.dept_id = department.dept_id);\n```\n\n==注：在MySQL中delete语句使用关联子查询时，不能使用表别名。==\n\n\n查找开户数最多的雇员：\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \nhaving count(*) = (select max(emp_cnt.how_many) \nfrom (select count(*) how_many \nfrom account \ngroup by open_emp_id) emp_cnt);\n```\n\n\n\n检索雇员数据，排序第一准则是老板姓氏，第二是雇员的姓氏：\n```\nselect emp.emp_id, concat(emp.fname, ' ', emp.lname) emp_name, \n(select concat(boss.fname, ' ', boss.lname) \nfrom employee boss \nwhere boss.emp_id = emp.superior_emp_id) boss_name \nfrom employee emp \nwhere emp.superior_emp_id is not null \norder by (select boss.lname from employee boss \nwhere boss.emp_id = emp.superior_emp_id), emp.lname;\n```\n\n\n### 再谈连接\n\n#### 外连接\n\n```\nselect a.account_id, a.cust_id, b.name \nfrom account a left outer join business b \non a.cust_id = b.cust_id;\n```\n\n\n##### 左外连接与右外连接\n\nleft指连接左边的表决定结果集的行数，而右边只负责提供与之匹配的列值：\n```\nselect c.cust_id,b.name \nfrom customer c left outer join business b \non c.cust_id = b.cust_id;\n```\n\n如果是右链接：\n```\nselect c.cust_id,b.name \nfrom customer c right outer join busines b \nwhere c.cust_id = b.cust_id;\n```\n\n##### 三路外连接\n\n```\nselect a.account_id, a.product_cd, \nconcat(i.fname, ' ', i.lname) person_name,\nb.name business_name \nfrom account a left outer join individual i \non a.cust_id = i.cust_id \nleft outer join business b \non a.cust_id = b.cust_id;\n```\n\n如果mysql对于外连接到同一个表的其他表的树木有限制，那么可以这么重写：\n```\nselect account_ind.account_id, account_ind.product_cd,\naccount_ind.person_name,\nb.name business_name \nfrom \n(select a.account_id, a.product_cd, a.cust_id, \nconcat(i.fname, ' ', i.lname) person name \nfrom account a left outer join individual i \non a.cust_id = i.cust_id) account_ind \nleft outer join business b \non account_ind.cust_id = b.cust_id;\n```\n\n\n##### 自外连接\n\n```\nselect e.fname, e.lname,\ne_mgr.fname mgr_fname, e_mgr.lname mgr_lname \nfrom employee e left outer join employee e_mgr \non e.superior_emp_id = e_mgr.emp_id;\n```\n#### 交叉连接\n\n```\nselect pt.name, p.product_cd, p.name \nfrom product p cross join product_type pt;\n```\n\n- 生成2008年全年日期\n```\nselect date_add('2008-01-01', interval (ones.num + tens.num + hundreds.num) day) dt  \nfrom \n(select 0 num union all \nselect 1 num union all \nselect 2 num union all \nselect 3 num union all \nselect 4 num union all \nselect 5 num union all \nselect 6 num union all \nselect 7 num union all \nselect 8 num union all \nselect 9 num) ones \ncross join \n(select 0 num union all \nselect 10 num union all \nselect 20 num union all \nselect 30 num union all \nselect 40 num union all \nselect 50 num union all \nselect 60 num union all \nselect 70 num union all \nselect 80 num union all \nselect 90 num) tens  \ncross join \n(select 0 num union all \nselect 100 num union all \nselect 200 num union all \nselect 300 num) hundreds \nwhere date_add('2008-01-01', \ninterval(ones.num+tens.num+hundreds.num) day) < '2009-01-01' \norder by 1;\n```\n\n==order by 1表示根据第一列的值自然排序。==\n\n\n#### 自然连接\n\n要避免不要使用自然连接。\n\n### 条件逻辑\n\n- 根据cust_type_cd字段判断决定使用indiv_name还是business_name列的值：\n```\nselect c.cust_id, c.fed_id,\ncase \nwhen c.cust_type_cd = 'I' \nthen concat(i.fname, ' ', i.lname) \nwhen c.cust_type_cd = 'B' \nthen b.name \nelse 'Unknown' \nend name \nfrom customer c left outer join individual i \non c.cust_id = i.cust_id \nleft outer join business b \non c.cust_id = b.cust_id;\n```\n\n#### case表达式\n\n##### 查找型case表达式\n\n```\nCASE \n    WHEN C1 THEN E1 \n    WHEN C2 THEN E2 \n    ...\n    WHEN CN THEN CN \n    [ELSE ED] \nEND\n```\n\n上面的语句可以改为：\n```\nselect c.cust_id, c.fed_id,\ncase\n    when c.cust_type_cd = 'I' then \n    (select concat(i.fname, ' ', i.lname) \n    from individual i \n    where i.cust_id = c.cust_id) \n    when c.cust_type_cd = 'B' then \n    (select b.name \n    from business b \n    where b.cust_id = c.cust_id) \n    else 'Unknown' \n    end name \nfrom customer c;\n```\n\n##### 结果集变换\n```\nselect year(open_date) year, count(*) how_many \nfrom account \nwhere open_date > '1999-12-31' \nand open_date < '2006-01-01' \ngroup by year(open_date);\n```\n\n结果是6行，如果想要变换成单行6列：\n```\nselect \n    sum(case \n            when extract(year from open_date) = 2000 then 1 \n            else 0 \n        end) year_2000,\n    sum(case \n            when extract(year from open_date) = 2001 then 1 \n            else 0 \n        end) year_2001,\n    sum(case \n            when extract(year from open_date) = 2002 then 1 \n            else 0 \n        end) year_2002,\n    sum(case \n            when extract(year from open_date) = 2003 then 1 \n            else 0 \n        end) year_2003,\n    sum(case \n            when extract(year from open_date) = 2004 then 1 \n            else 0 \n        end) year_2004,\n    sum(case \n            when extract(year from open_date) = 2005 then 1 \n            else 0 \n        end) year_2005\nfrom account \nwhere open_date > '1999-12-31' and open_date < '2006-01-01';\n```\n        \n        \n##### 存在性检查\n\n```\nselect c.cust_id, c.fed_id, c.cust_type_cd,\n    case \n        when exists (select 1 from account a \n        where a.cust_id = c.cust_id \n        and a.product_cd = 'CHK') then 'Y' \n        else 'N' \n    end has_checking,\n    case\n        when exists (select 1 froom account a \n        where a.cust_id = c.cust_id \n        and a.product_cd = 'SAV') then 'Y' \n        else 'N' \n    end has_savings \nfrom customer c;\n```\n\n##### 除零错误\n\n```\nselect a.cust_id, a.product_cd, a.avail_balance / \n case\n  when prod_tots.tot_balance = 0 then 1 \n  else prod_tots.tot_balance \n end percent_of_total \nfrom account a inner join \n(select a.product_cd, sum(a.avail_balance) tot_balance \nfrom account a \ngroup by a.product_cd) prod_tots \non a.product_cd = prod_tots.product_cd;\n```\n\n### 事务\n\n#### 多用户数据库\n\n##### 锁\n\n两种锁……\n- ==写锁+读锁==\n- 写锁，读取不需要锁。服务器要保证从查询开始到结束读操作看到一个一致的数据视图，这个方法被称为==版本控制==。\n\n##### 锁的粒度\n\n- 表锁\n- 页锁（阻止多用户同时修改某表中同一页（一页通常是一段2～16KB的内存空间）的数据）\n- 行锁\n\n\n**显式启动事务**：\n- SQL Server\n```\nbegin transaction\n```\n- MySQL\n```\nstart transaction\n```\n\n**关闭自动提交：**\n- SQL Server\n\n```\nset implicit_transactions on\n```\n- MySQL\n```\nset autocommit=0\n```\n\n\n对于SQL Server和MySQL，默认自动提交模式，直到显示启动一个事务。\n\n一旦离开了自动提交模式，所有的SQL命令都会发生在同一个事务的范围，并且必须显式地对事务进行提交或回滚。\n\n##### 结束事务\n\n- commit\n- rollback\n\n除了提交commit或rollback指令，结束事务还可以有其他情景触发：\n- 服务器宕机\n- 提交一个SQL模式语句，比如alter table，这将会引起当前事务提交和一个新事务启动\n- 提交另一个start transaction命令，将会引起前一个事务提交\n- 因为服务器监测到一个死锁，并确定当前事务是罪魁祸首，服务器将会结束当前事务。这种情况下，事务将会被回滚，同时释放错误消息（大多数情况喜爱，终止的事务可以重启，如果没有再次遇到另一个死锁情况他将会成功）\n\n\n##### 事务保存点\n\n6.0版的MySQL包括以下存储引擎：\n- MyISAM    表级锁定的非事务引擎\n- MEMORY    内存表使用的非事务引擎\n- BDB       页级锁定的事务引擎\n- InnoDB    行级锁定的事务引擎\n- Merge     使多个相同的MyISAM看起来像一个单表（也叫表分割）的专用引擎\n- Maria     6.0.6版本中MyISAM的替代品，他添加了充分的恢复功能\n- Falcon    6.0.4版本起引入的采用行级锁定的高性能事务引擎\n- Archive   用于存储大量未检索数据的专用引擎，主要用来存档\n\n查看引擎：\n```\nshow table status like 'transaction' \\G\n```\n\n设置引擎：\n```\nalter table transaction engine = innodb;\n```\n\n\n- **创建保存点**\n\n```\nsavepoint my_savepoint;\n```\n\n- **回滚到保存点**\n\n```\nrollback to savepoint my_savepoint;\n```\n\n### 索引和约束\n\n\n#### 索引\n索引是一种以特定顺序保存的专用表。\n\n\n##### 创建索引\n\n```\nalter table department \nadd index dept_name_idx (name);\n```\n\n- 查看索引\n```\nshow index from department \\G\n```\n\n创建表时的包含一个约束，该约束将primary key dept_id列作为主关键字。\n\n- 删除索引\n```\nalter table department \ndrop index dept_name_idx;\n```\n\n- **唯一索引**\n\n\n设计数据库时，需要考虑哪些列能包含重复数据，哪些列不能。\n例如department表中不能出现两个相同名字的部门。可以通过department.name创建唯一索引限制出现重复部门名字。\n\n```\nalter table department \nadd unique dept_name_idx (name);\n```\n\n\n\n- **多列索引**\n\n```\nalter table employee \nadd index emp_names_idx (lname, fname);\n```\n\n\n创建多列索引时，必须考虑哪一列作为第一列，哪一列作为第二列，这样索引才会尽可能的有用。\n\n##### 索引类型\n\n- **B树索引**\n\n平衡树索引\n\nMySQL、Oracle、SQL Server默认都是B树索引。\n\n当向表中插入、更新和删除行时，服务器会尽力保持树的平衡。\n\n\n- **位图索引**\n\n位图索引通常应用于数据仓库环境，那里有大量数据被索引，那些列却只包含相对少的值（比如销售岗位、地理环境、产品、销售员）\n\n- **文本索引**\n\nMySQL、SQL Server   全文索引\nOracle              Oracle Text\n\n##### 如何使用索引\n\n```\nexplain select cust_id, sum(avail_balance) tot_bal \nfrom account \nwhere cust_id in (1,5,9,11) \ngroup by cust_id \\G\n```\n\n结果：\n```\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: account\n   partitions: NULL\n         type: index\npossible_keys: fk_a_cust_id\n          key: fk_a_cust_id\n      key_len: 4\n          ref: NULL\n         rows: 24\n     filtered: 33.33\n        Extra: Using where\n1 row in set, 1 warning (0.01 sec)\n```\n\n\n优化，给cust_id和avail_balance两列添加新索引：\n```\nalter table account \nadd index acc_bal_idx (cust_id, avail_balance);\n```\n\n再次查询优化器是如何处理的：\n```\nexplain select cust_id, sum(avail_balance) tot_bal \nfrom account \nwhere cust_id in (1,5,9,11) \ngroup by cust_id \\G\n```\n结果如下：\n```\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: account\n   partitions: NULL\n         type: range\npossible_keys: acc_bal_idx\n          key: acc_bal_idx\n      key_len: 4\n          ref: NULL\n         rows: 8\n     filtered: 100.00\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.01 sec)\n```\n\n- ==优化器使用了新索引，而不是fk_a_cust_id==\n- ==优化器预期只需要8行，而不是24行==\n- ==不需要account表即可满足查询结果（使用附加列的索引指定）==\n\n##### 索引的不足\n\n\n- 每个索引其实 都是一个表\n- 每次在对表添加或删除行时，表中的所有索引必须被修改，当更新行时，受到影响的列的任何索引也必须被修改。\n- 索引越多，服务器就需要做越多的工作来保持所有模式对象最新。\n\n\n默认策略：\n- ==确保所有的主键列被索引==（大部分服务器会在创建主键约束时自动生成唯一索引），针对多列主键，考虑为主键列的子集构建附加索引，或者以与主键约束定义不同的顺序为所有主键列另外生成索引\n- ==为所有被外键约束引用的列创建索引。== 服务器在准备删除父行时会查找以确保没有子行存在，为此他必须发出一个查询搜索列中的特定值，如果该列没有索引，那么服务器必须扫描整个表\n- ==索引那些被频繁检索的列。除了短字符串（3～50个字符）列，大多数日期列也是不错的候选==\n\n\n#### 约束\n\n- 主键约束\n- 外键约束\n- 唯一约束\n- 检查约束\n\n**创建约束**\n```sql\ncreate table product \n(product_cd varchar(10) not null,\nname varchar(50) not null,\nproduct_type_cd varchar(10) not null,\ndate_offered date,\ndate_retired date,\nconstraint fk_product_type_cd foreign key (product_type_cd) \nreferences product_type (product_type_cd) ,\nconstraint pk_product primary key (product_cd)\n);\n\n```\n\n\n##### 约束与索引\n\nMySQL 主键约束、外键约束和唯一约束时，都会生成索引。\n\n##### 级联约束\n\n\n- on updae cascade\n\n```sql\nalter table product \ndrop foreign key fk_product_type_cd;\n\nalter table product \nadd constraint fk_product_type_cd foreign key (product_type_cd) \nreferences product_type (product_type_cd) \non update cascade;\n```\n\n- on delete cascade\n\n```\nalter table product \nadd constraint fk_product_type_cd foreign key (product_type_cd) \nreferences product_type (product_type_cd) \non update cascade \non delete cascade;\n```\n\n\n### 视图\n\n创建视图\n```\ncreate view customer_vw \n(cust_id,\nfed_id,\ncust_type_cd,\naddress,\ncity,\nstate,\nzipcode\n)\nas\nselect cust_id,\nconcat('ends in ', substr(fed_id,8,4)) fed_id, \ncust_type_cd,\naddress,\ncity,\nstate,\npostal_code\nfrom customer;\n```\n使用视图\n```\nselect cust_id, fed_id, cust_type_cd \nfrom customer_vw;\n```\n\n服务器真正执行的查询是将两者合并创建的一个新查询：\n```\nselect cust_id,\nconcat(\"ends in \", substr(fed_id,8,4)) fed_id,\ncust_type_cd \nfrom customer;\n```\n\n查看视图有哪些列：\n```\ndescribe customer_vw;\n```\n\n\n```\nselect cst.cust_id, cst.fed_id, bus.name \nfrom customer_vw cst inner join business bus \non cst.cust_id = bus.cust_id;\n```\n\n#### 为什么使用视图\n\n##### 数据安全\n\n只能查询企业用户：\n```\ncreate view business_customer_vw \n(cust_id,\nfed_id,\ncust_type_cd,\naddress,\ncity,\nstate,\nzipcode\n) \nas \nselect cust_id,\nconcat('ends in ', substr(fed_id, 8, 4)) fed_id,\ncust_type_cd,\naddress,\ncity,\nstate,\npostal_code \nfrom customer \nwhere cust_type_cd = 'B';\n```\n\n\n##### 数据聚合\n\n生成报表展示账户数据和每个客户的储蓄总额：\n```\ncreate view customer_totals_vw \n(cust_id,\ncust_type_cd,\ncust_name,\nnum_accounts,\ntot_deposits) \nas \nselect cst.cust_id, cst.cust_type_cd,\n case \n  when cst.cust_type_cd = 'B' then \n  (select bus.name from business bus where bus.cust_id = cst.cust_id) \n  else \n  (select concat(ind.fname, ' ', ind.lname) \n  from individual ind \n  where ind.cust_id = cst.cust_id) \n end cust_name,\n sum(case when act.status = 'ACTIVE' then 1 else 0 end) tot_active_accounts,\n sum(case when act.status = 'ACTIVE' then act.avail_balance else 0 end) tot_balance \nfrom customer cst inner join account act \non act.cust_id = cst.cust_id \ngroup by cst.cust_id, cst.cust_type_cd;\n```\n\n决定将数据预聚合到一个表中而不是利用视图总计，那么可以先创建customer_totals表，然后修改视图customer_totals_vw定义，再从该表中检索数据。\n```\ncreate table customer_totals  \nas \nselect * from customer_totals_vw;\n```\n\n```\ncreate or replace view customer_totals_vw \n(cust_id,\ncust_type_cd,\ncust_name,\nnum_accounts,\ntot_deposits\n) \nas \nselect cust_id, cust_type_cd, cust_name, num_accounts, tot_deposits \nfrom customer_totals;\n```\n\n##### 隐藏复杂性\n\n##### 连接分区数据\n\ntransaction变的越来越大，那么设计者可以将其分为两个表：transaction_current,transaction_historic。然后可以通过视图将两个表联合起来：\n```\ncreate view transaction_vw \n(txn_date,\naccount_id,\ntxn_type_cd,\namount,\nteller_emp_id,\nexecution_branch_id,\nfunds_avail_date\n) \nas \nselect txn_date, account_id, txn_type_cd, amount, teller_emp_id, \nexecution_branch_id, funds_avail_date \nfrom transaction_historic \nunion all \nselect txn_date, account_id, txn_type_cd, amount, teller_emp_id, \nexecution_branch_id, funds_avail_date \nfrom transaction_current;\n```\n\n\n#### 可更新的视图\n\n对于MySQL，如果以下条件能满足，那么视图就是可更新的：\n- 没有使用聚合函数，例如max()、min()、avg() 等\n- 视图没有使用group by或having子句\n- select或from子句中不存在子查询，并且where子句中的任何子查询都不引用from子句中的表\n- 视图没有使用union、union all和distinct\n- from子句包括不止一个表或可更新视图\n- 如果有不止一个表或视图，那么from子句只使用内连接\n\n修改视图：\n```\nupdate customer_vw \nset city = 'Woooburn' \nwhere city =  'Woburn';\n```\n\n\n### 元数据\n\n- 元数据——数据的数据\n- 数据字典或者系统目录\n\n\n#### 信息模式\n\n- ==information_schema数据库==里所有可用对象是视图\n\n检索bank数据库里所有表的名字：\n```\nselect table_name, table_type \nfrom information_schema.tables \nwhere table_schema = 'bank' \norder by 1;\n```\n\n在结果中排除视图：\n```\nselect table_name, table_type \nfrom information_schema.tables \nwhere table_schema = 'bank' and table_type = 'BASE TABLE' \norder by 1;\n```\n\n只检索视图：\n```\nselect table_name,is_updatable \nfrom information_schema.views \nwhere table_schema='bank' \norder by 1;\n```\n\n\n查看表的信息：\n```\nselect column_name,data_type,character_maximum_length char_max_len,\nnumeric_precision num_prcsn, numeric_scale num_scale \nfrom infromation_schema.columns \nwhere table_schema='bank' and table_name='account' \norder by ordinal_position;\n```\n\n\n查询表中的索引信息：\n```\nselect index_name,non_unique,seq_in_index,column_name \nfrom information_schema.statistics \nwhere table_schema = 'bank' and table_name = 'account' \norder by 1,3;\n```\n\n查询bank模式中的所有视图：\n```\nselect constraint_name,table_name,constraint_type \nfrom information_schema.table_constraints \nwhere table_schema = 'bank' \norder by 3,1;\n```\n\n#### 使用元数据\n\n##### 模式生成脚本\n\n##### 生成动态SQL\n\nMySQL为动态SQL执行提供了：\n- prepare\n- execute\n- deallocate\n语句\n\n\n```\n--将sql语句赋给变量qry\nset @qry = 'select cust_id, cust_type_cd, fed_id from customer';\n\n-- qry被prepare语句提交给数据库引擎（解析、安全检查、优化）\nprepare dynsql1 from @qry;\n\n-- 执行\nexecute dynsql1;\n\n-- deallocate prepare关闭语句，释放执行中使用的所有数据库资源（如游标）\ndeallocate prepare dynsql1;\n\n```\n\n\n\n```\n-- 查询包含占位符\nset @qry = 'select product_cd, name, product_type_cd, date_offered, date_retired from product where product_cd = ?';\n\nprepare dynsql2 from @qry;\n\nset @prodcd = 'CKH';\n\nexecute dynsql2 using @prodcd;\n\nset @prodcd = 'SAV';\n\nexecute dynsql2 usging @prodcd;\n\ndeallocate prepare dynsql2;\n\n```\n\n可以通过使用元数据生成动态SQL查询语句，而不是使用上面的硬编码。\n\n\n### MySQL对SQL语言的扩展\n\n#### limit子句\n\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \nlimit 3;\n```\n\n\n- 组合limit子句和order by子句\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \norder by how_many desc \nlimit 3;\n```\n\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \norder by how_many desc \nlimit 2,1;\n```\n\n```\nselect open_emp_id, count(*) how_many \nfrom account \ngroup by open_emp_id \norder by how_many desc \nlimit 2,999999999;\n```\n\n\n##### into outfile子句\n\n```\nselect emp_id, fname, lname, start_date \ninto outfile 'C:\\\\TEMP||emp_list.txt' \nfrom employee;\n```\n默认列间用制表符（'\\t'）隔开，记录间用换行符（'\\n'）隔开。\n\n- 改成用字符 '|'隔开\n```\nselect emp_id, fname, lname, start_date \ninto outfile 'C:\\\\TEMP||emp_list.txt' \nfields terminated by '|' \nlines terminated by '@' \nfrom employee;\n```\n\n\n##### 组合insert/update语句\n\n更新插入（upsert）\n\n```\ninsert into branch_usage (branch_id, cust_id, last_visited_on) \nvalues (1,5, current_timestamp()) \non duplicate key update last_visited_on = current_timestamp();\n```\n\n\n##### 多表更新与删除\n\n同时删除account、customer、individual表中的某一个客户数据\n\n```\ndelete account2, customer2, individual2 \nfrom account2 inner join customer2 \non account2.cust_id=customer2.cust_id \ninner join individual2 \non customer2.cust_id = individual2.cust_id \nwhere individual2.cust_id = 1;\n```\n\n\n\n\n\n\n\n\n","slug":"《SQL学习指南》笔记","published":1,"updated":"2018-12-15T11:30:33.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzp88may000g7n8ubuttfc38","content":"<h3 id=\"创建和使用数据库\"><a href=\"#创建和使用数据库\" class=\"headerlink\" title=\"创建和使用数据库\"></a>创建和使用数据库</h3><ul>\n<li><p>主键约束<br><code>constraint pk_person primary key (person_id)</code></p>\n</li>\n<li><p>检查约束<br><code>gender char(1) check (gender in (&#39;M&#39;,&#39;F&#39;)),</code></p>\n</li>\n</ul>\n<p>或用<code>gender ENUM(&#39;M&#39;,&#39;F&#39;),</code>代替检查约束</p>\n<a id=\"more\"></a>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> person</span><br><span class=\"line\">(person_id <span class=\"built_in\">smallint</span> <span class=\"keyword\">unsigned</span>,</span><br><span class=\"line\">fname <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">lname <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">gender enum(<span class=\"string\">'M'</span>,<span class=\"string\">'F'</span>),</span><br><span class=\"line\">birth_date <span class=\"built_in\">date</span>,</span><br><span class=\"line\">street <span class=\"built_in\">varchar</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">city <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">state <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">country <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">postal_code <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> pk_person primary <span class=\"keyword\">key</span> (person_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> favorite_food</span><br><span class=\"line\">(person_id <span class=\"built_in\">smallint</span> <span class=\"keyword\">unsigned</span>,</span><br><span class=\"line\">food <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> pk_favorite_food primary <span class=\"keyword\">key</span> (person_id, food),</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> fk_fav_food_person_id <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> (person_id)</span><br><span class=\"line\"><span class=\"keyword\">references</span> person (person_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><strong>此时想要给person表主键增加auto_incremnt</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table person modify person_id smallint unsigned auto_increment;</span><br></pre></td></tr></table></figure></p>\n<p>报错，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error Code: 1833. Cannot change column &apos;person_id&apos;: used in a foreign key constraint &apos;fk_fav_food_person_id&apos; of table &apos;table.favorite_food&apos;</span><br></pre></td></tr></table></figure></p>\n<p>，因为被用在favorite_food表中作为外键了，不允许修改，</p>\n<p>==Solution 1==：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock tables </span><br><span class=\"line\">favorite_food write,</span><br><span class=\"line\">person write;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table favorite_food </span><br><span class=\"line\">drop foreign key fk_fav_food_person_id,</span><br><span class=\"line\">modify person_id smallint unsigned;</span><br></pre></td></tr></table></figure>\n<p>然后再修改person主键<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table person modify person_id smallint unsigned auto_increment;</span><br></pre></td></tr></table></figure></p>\n<p>创建外键<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table favorite_food </span><br><span class=\"line\">add constraint fk_fav_food_person_id foreign key (person_id) </span><br><span class=\"line\">references person (person_id);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unlock tables;</span><br></pre></td></tr></table></figure>\n<p>==solution 2==</p>\n<p>You can turn off foreign key checks:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">/* DO WHAT YOU NEED HERE */</span><br><span class=\"line\"></span><br><span class=\"line\">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure>\n<p>插入一条数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into person </span><br><span class=\"line\">(person_id, fname, lname,gender,birth_date) </span><br><span class=\"line\">values (null, &apos;William&apos;, &apos;Turner&apos;,&apos;M&apos;,&apos;1972-05-27&apos;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into favorite_food (person_id,food) </span><br><span class=\"line\">values (1, &apos;pizza&apos;);</span><br><span class=\"line\">insert into favorite_food (person_id,food) </span><br><span class=\"line\">values (1, &apos;cookies&apos;);</span><br><span class=\"line\">insert into favorite_food (person_id,food) </span><br><span class=\"line\">values (1, &apos;nachos&apos;);</span><br></pre></td></tr></table></figure>\n<p>更新数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update person </span><br><span class=\"line\">set street=&apos;1225 Tremont St.&apos;,</span><br><span class=\"line\">city=&apos;Boston&apos;,</span><br><span class=\"line\">state=&apos;MA&apos;,</span><br><span class=\"line\">country=&apos;USA&apos;,</span><br><span class=\"line\">postal_code=&apos;02138&apos; </span><br><span class=\"line\">where person_id=1;</span><br></pre></td></tr></table></figure></p>\n<p>删除数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from person </span><br><span class=\"line\">where person_id=2;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">&apos;ACTIVE&apos;,</span><br><span class=\"line\">emp_id * 3.14159,</span><br><span class=\"line\">UPPER(lname) </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<p>执行内建函数或对简单的表达式求值可以完全省略from子句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select version(),</span><br><span class=\"line\">user(),</span><br><span class=\"line\">database();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列的别名：\"><a href=\"#列的别名：\" class=\"headerlink\" title=\"列的别名：\"></a>列的别名：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,</span><br><span class=\"line\">&apos;ACTIVE&apos; status,</span><br><span class=\"line\">emp_id * 3.14159 empid_x_pi,</span><br><span class=\"line\">UPPER(lname) last_name_upper </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<p>(可以在别名前加上AS关键字)</p>\n<h4 id=\"去除重复的行\"><a href=\"#去除重复的行\" class=\"headerlink\" title=\"去除重复的行\"></a>去除重复的行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct cust_id </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure>\n<p>==注：产生无重复的结果集需要首先对数据排序，因此，不要为了确保去重二使用DiSTINCT，而应先了解所使用的数据是否可能包含重复的行。==</p>\n<h4 id=\"from子句\"><a href=\"#from子句\" class=\"headerlink\" title=\"from子句\"></a>from子句</h4><p>from子句定义了查询中所使用的表，以及连接这些表的方式。</p>\n<ul>\n<li>表<ul>\n<li>永久表（create table语句创建的表）</li>\n<li>临时表（子查询返回的表）</li>\n<li>虚拟表（create view）</li>\n</ul>\n</li>\n</ul>\n<p>通过别名e来引用子查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.emp_id, e.fname, e.lname </span><br><span class=\"line\">from (select emp_id,fname,lname,start_date,title </span><br><span class=\"line\">from employee) e;</span><br></pre></td></tr></table></figure></p>\n<p>视图是存储在数据字典中的查询，它的行为表现的像一个表，但实际上并不拥有任何数据（因此称为虚拟表）。当发出一个对视图的查询时，该查询会被绑定到视图定义上，以产生最终被执行的查询。</p>\n<ol>\n<li>定义一个查询employee表的视图</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view employee_vw AS </span><br><span class=\"line\">select emp_id, fname, lname, </span><br><span class=\"line\">YEAE(start_date) start_year </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>查询视图</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, start_year </span><br><span class=\"line\">from employee_vw;</span><br></pre></td></tr></table></figure>\n<h5 id=\"表连接\"><a href=\"#表连接\" class=\"headerlink\" title=\"表连接\"></a>表连接</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select employee.emp_id,employee.fname,employee.lname,</span><br><span class=\"line\">department.name dept_name </span><br><span class=\"line\">from employee inner join department </span><br><span class=\"line\">on employee.dept_id=department.dept_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"定义表别名\"><a href=\"#定义表别名\" class=\"headerlink\" title=\"定义表别名\"></a>定义表别名</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.emp_id,e.fname,e.lname,</span><br><span class=\"line\">d.name dept_name </span><br><span class=\"line\">from employee e inner join department d </span><br><span class=\"line\">on e.dept_id=d.dept_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"where子句\"><a href=\"#where子句\" class=\"headerlink\" title=\"where子句\"></a>where子句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date,title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where title=&apos;Head Teller&apos; </span><br><span class=\"line\">AND start_date &gt; &apos;2006-01-01&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"group-by和having子句\"><a href=\"#group-by和having子句\" class=\"headerlink\" title=\"group by和having子句\"></a>group by和having子句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select d.name,count(e.emp_id) num_employees </span><br><span class=\"line\">from department d inner join employee e </span><br><span class=\"line\">on d.dept_id=e.dept_id </span><br><span class=\"line\">group by d.name </span><br><span class=\"line\">having count(e.emp_id) &gt; 2;</span><br></pre></td></tr></table></figure>\n<h4 id=\"order-by\"><a href=\"#order-by\" class=\"headerlink\" title=\"order by\"></a>order by</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, product_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">order by open_emp_id;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>升序（ASC、默认）</li>\n<li>降序DESC</li>\n</ul>\n<h5 id=\"根据表达式排序\"><a href=\"#根据表达式排序\" class=\"headerlink\" title=\"根据表达式排序\"></a>根据表达式排序</h5><p>使用right()内建函数提取fed_id列的最后三个字符排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,cust_type_cd,city,state,fed_id </span><br><span class=\"line\">from customer </span><br><span class=\"line\">order by right(fed_id, 3);</span><br></pre></td></tr></table></figure>\n<h5 id=\"根据数字占位符排序\"><a href=\"#根据数字占位符排序\" class=\"headerlink\" title=\"根据数字占位符排序\"></a>根据数字占位符排序</h5><p>根据查询返回的第2，5列排序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,title,start_date,fname.lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">order by 2,5;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h3><h4 id=\"条件类型\"><a href=\"#条件类型\" class=\"headerlink\" title=\"条件类型\"></a>条件类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select pt.name product_type,p.name product </span><br><span class=\"line\">from product p inner join product_type pt </span><br><span class=\"line\">on p.product_type_cd = pt.product_type_cd </span><br><span class=\"line\">where pt.name = &apos;Customer Accounts&apos;;</span><br></pre></td></tr></table></figure>\n<p>不等条件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select pt.name product_type,p.name product </span><br><span class=\"line\">from product p inner join product_type pt </span><br><span class=\"line\">on p.product_type_cd = pt.product_type_cd </span><br><span class=\"line\">where pt.name &lt;&gt; &apos;Customer Accounts&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>描述不等条件时，可以用<code>&lt;&gt;</code>也可以用<code>!=</code></p>\n<h5 id=\"范围条件\"><a href=\"#范围条件\" class=\"headerlink\" title=\"范围条件\"></a>范围条件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where start_date&lt;&apos;2007-01-01&apos;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where start_date &lt;&apos;2007-01-01&apos; </span><br><span class=\"line\">and start_date &gt;= &apos;2005-01-01&apos;;</span><br></pre></td></tr></table></figure>\n<p>between(两端都是包含)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where start_date between &apos;2005-01-01&apos; and &apos;2006-12-31&apos;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,fed_id </span><br><span class=\"line\">from customer </span><br><span class=\"line\">where cust_type_cd=&apos;I&apos;</span><br><span class=\"line\">and fed_id between &apos;500-00-0000&apos; and &apos;999-99-9999&apos;;</span><br></pre></td></tr></table></figure>\n<p>in操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_id,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd in (&apos;CHK&apos;,&apos;SAV&apos;,&apos;CD,&apos;MM&apos;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_id,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd in (select product_cd from product </span><br><span class=\"line\">where product_type_cd = &apos;ACCOUNT&apos;);</span><br></pre></td></tr></table></figure>\n<p>not in<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_cd,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd not in (&apos;CHK&apos;,&apos;SAV&apos;,&apos;CD&apos;,&apos;MM&apos;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"匹配条件\"><a href=\"#匹配条件\" class=\"headerlink\" title=\"匹配条件\"></a>匹配条件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where left(lname,1)=&apos;T&apos;;</span><br></pre></td></tr></table></figure>\n<p>可以使用内建函数left()，但更好的做法是使用通配符：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where lname like &apos;_a%e%&apos;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,fed_id </span><br><span class=\"line\">from customer </span><br><span class=\"line\">where fed_id like &apos;___-__-____&apos;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname </span><br><span class=\"line\">from employee</span><br><span class=\"line\">where lname like &apos;F%&apos; or lname like &apos;G%&apos;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where lname regexp &apos;^[FG]&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,superior_emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where superior_emp_id is NULL;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h3><h5 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h5><p>交叉连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname,d.name </span><br><span class=\"line\">from employee e join department d;</span><br></pre></td></tr></table></figure>\n<h5 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h5><p>如果在一个表中的dept_id列中存在某个值，但该值在另一张表的dept_id列中不存在，那么相关行的连接会失败，在结果集中将会排除包含该值的行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname,d.name </span><br><span class=\"line\">from employee e join department d </span><br><span class=\"line\">on e.dept_id = d.dept_id;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上面没加inner关键字，默认使用inner，但最好加上。</li>\n<li>如果连接两个表的列名是相同的，可以使用using子句代替on子句：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname,d.name </span><br><span class=\"line\">from employee e inner join department d </span><br><span class=\"line\">using (dept_id);</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接3个或更多的表\"><a href=\"#连接3个或更多的表\" class=\"headerlink\" title=\"连接3个或更多的表\"></a>连接3个或更多的表</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id,c.fed_id,e.fname,e.lname </span><br><span class=\"line\">from account a inner join customer c </span><br><span class=\"line\">on a.cust_id=c.cust_id </span><br><span class=\"line\">inner join employee e </span><br><span class=\"line\">on a.open_emp_id = e.emp_id </span><br><span class=\"line\">where c.cust_type_cd = &apos;B&apos;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"将子查询结果作为查询表\"><a href=\"#将子查询结果作为查询表\" class=\"headerlink\" title=\"将子查询结果作为查询表\"></a>将子查询结果作为查询表</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id,a.cust_id,a.open_date,a.product_cd </span><br><span class=\"line\">from account a INNER JOIN </span><br><span class=\"line\">    (select emp_id,assigned_branch_id </span><br><span class=\"line\">    from employee </span><br><span class=\"line\">    where start_date &lt; &apos;2007-01-01&apos; </span><br><span class=\"line\">    and (title = &apos;Teller&apos; OR title = &apos;Head Teller&apos;)) e</span><br><span class=\"line\">    ON a.open_emp_id = e.emp_id </span><br><span class=\"line\">    INNER JOIN</span><br><span class=\"line\">        (select branch_id </span><br><span class=\"line\">        from branch </span><br><span class=\"line\">        where name = &apos;Woburn Branch&apos;) b </span><br><span class=\"line\">        ON e.assigned_branch_id = b.branch_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"连续两次使用同一个表\"><a href=\"#连续两次使用同一个表\" class=\"headerlink\" title=\"连续两次使用同一个表\"></a>连续两次使用同一个表</h5><p>需要给每个branch表的实例定义不用的别名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id,e.emp_id,</span><br><span class=\"line\">b_a.name open_branch,b_e.name emp_branch </span><br><span class=\"line\">from account a inner join branch b_a </span><br><span class=\"line\">on a.open_branch_id=b_a.branch_id </span><br><span class=\"line\">inner join employee e </span><br><span class=\"line\">on a.open_emp_id=e.emp_id </span><br><span class=\"line\">inner join branch b_e </span><br><span class=\"line\">on e.assigned_branch_id=b_e.branch_id </span><br><span class=\"line\">where a.product_cd=&apos;CHK&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自连接\"><a href=\"#自连接\" class=\"headerlink\" title=\"自连接\"></a>自连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname </span><br><span class=\"line\">e_mgr.fname mgr_fname,e_mgr.lname mgr_lname </span><br><span class=\"line\">from employee e inner join employee e_mgr </span><br><span class=\"line\">on e.superior_emp_id = e_mgr.emp_id;</span><br></pre></td></tr></table></figure>\n<p>上面语句列出了雇员姓名和主管姓名，但是employee表中一共有18行，但此查询只返回17行，这是由于银行的总经理并没有自己的主管（superior_emp_id列为null），因此在该行连接失败了。为了在结果集中包含这个数据，应使用外连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e1.fname, e1.lname, &apos;VS&apos; vs, e2.fname, e2.lname </span><br><span class=\"line\">from employee e1 inner join employee e2 </span><br><span class=\"line\">on e1.emp_id &lt; e2.emp_id </span><br><span class=\"line\">where e1.title=&apos;Teller&apos; and e2.title = &apos;Teller&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接条件和过滤条件\"><a href=\"#连接条件和过滤条件\" class=\"headerlink\" title=\"连接条件和过滤条件\"></a>连接条件和过滤条件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, c.fed_id </span><br><span class=\"line\">from account a inner join customer c </span><br><span class=\"line\">on a.cust_id = c.cust_id </span><br><span class=\"line\">where c.cust_type_cd = &apos;B&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用集合\"><a href=\"#使用集合\" class=\"headerlink\" title=\"使用集合\"></a>使用集合</h3><ul>\n<li>当对两个数据集合执行集合操作时，必须满足：<ul>\n<li>两个数据集合必须具有同样数目的列</li>\n<li>两个数据集中对应列的数据类型必须是一样的（或者服务器能偶从一种转换成另一种）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 1 num, &apos;abc&apos; str </span><br><span class=\"line\">union </span><br><span class=\"line\">select 9 num, &apos;xyz&apos; str;</span><br></pre></td></tr></table></figure>\n<h5 id=\"union操作符\"><a href=\"#union操作符\" class=\"headerlink\" title=\"union操作符\"></a>union操作符</h5><p>union对连接后的集合排序并去除重复项，而union all保留重复项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;IND&apos; type_cd, cust_id, lname name </span><br><span class=\"line\">from individual </span><br><span class=\"line\">union all </span><br><span class=\"line\">select &apos;BUS&apos; type_cd, cust_id, name </span><br><span class=\"line\">from business;</span><br></pre></td></tr></table></figure>\n<p>返回重复数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where assigned_branch_id=2 </span><br><span class=\"line\">and (title=&apos;Teller&apos; or title=&apos;Head Teller&apos;) </span><br><span class=\"line\">union all </span><br><span class=\"line\">select distinct open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = 2;</span><br></pre></td></tr></table></figure>\n<p>查询结果含有重复项，如果要排除重复项，需要把union all改成union</p>\n<h5 id=\"intersect-操作符\"><a href=\"#intersect-操作符\" class=\"headerlink\" title=\"intersect 操作符\"></a>intersect 操作符</h5><p>intersect 查找交集，并且去除了交集区域中所有重复的行，不删除重复的的是intersect all操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where assigned_branch_id=2 </span><br><span class=\"line\">and (title=&apos;Teller&apos; or title=&apos;Head Teller&apos;) </span><br><span class=\"line\">intersect  </span><br><span class=\"line\">select distinct open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = 2;</span><br></pre></td></tr></table></figure>\n<h5 id=\"except操作符\"><a href=\"#except操作符\" class=\"headerlink\" title=\"except操作符\"></a>except操作符</h5><p>except操作符返回第一个表减去第二个表重合的元素后剩下的部分。<br>except在集合A中去除所有的重复数据，而except all则根据重复数据在集合B中出现的次数进行删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where assigned_branch_id=2 </span><br><span class=\"line\">and (title=&apos;Teller&apos; or title=&apos;Head Teller&apos;) </span><br><span class=\"line\">except   </span><br><span class=\"line\">select distinct open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = 2;</span><br></pre></td></tr></table></figure>\n<h5 id=\"集合操作符优先级\"><a href=\"#集合操作符优先级\" class=\"headerlink\" title=\"集合操作符优先级\"></a>集合操作符优先级</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd in (&apos;SAV&apos;,&apos;MM&apos;) </span><br><span class=\"line\">union all </span><br><span class=\"line\">select a.cust_id </span><br><span class=\"line\">from account a inner join branch b </span><br><span class=\"line\">on a.open_branch_id = b.branch_id </span><br><span class=\"line\">where b.name = &apos;Woburn Branch&apos; </span><br><span class=\"line\">union </span><br><span class=\"line\">select cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where avail_balance between 500 and 2500;</span><br></pre></td></tr></table></figure>\n<p>复合查询包含3个或3个以上的查询语句，他们是自顶向下的顺序解析和执行的，但要注意：</p>\n<ul>\n<li>在调用集合操作时，intersect操作符比其他操作符具有更高的优先级</li>\n<li>可以用圆括号对多个查询进行封装，以明确指定他们的指定次序</li>\n</ul>\n<p>MySQL 没有实现intersect操作符</p>\n<h3 id=\"数据生成、转换和操作\"><a href=\"#数据生成、转换和操作\" class=\"headerlink\" title=\"数据生成、转换和操作\"></a>数据生成、转换和操作</h3><h4 id=\"使用字符串数据\"><a href=\"#使用字符串数据\" class=\"headerlink\" title=\"使用字符串数据\"></a>使用字符串数据</h4><ul>\n<li><code>CHAR</code><ul>\n<li>固定长度，不足部分使用空格填充的字符串</li>\n<li>MySQL的CHAR类型的长度为255字节。</li>\n<li>Oracle为2000</li>\n<li>SQL Server 8000</li>\n</ul>\n</li>\n<li><code>varchar</code><ul>\n<li>变长字符串。</li>\n<li>MySQL允许的varchar列最多包含65536个字符</li>\n<li>Oracle为4000</li>\n<li>SQL Server为8000</li>\n</ul>\n</li>\n<li><code>text</code>(MySQL和SQL Server) 或 <code>CLOB</code>(Character Large Object; Oracle)<ul>\n<li>MySQL有多种text类型，最多4GB</li>\n<li>SQL只有text，最长2GB</li>\n<li>Oracle的CLOB，最大128TB</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table string_tbl</span><br><span class=\"line\">(char_fld CHAR(30),</span><br><span class=\"line\">vchar_fld varchar(30),</span><br><span class=\"line\">text_fld text);</span><br></pre></td></tr></table></figure>\n<h5 id=\"生成字符串\"><a href=\"#生成字符串\" class=\"headerlink\" title=\"生成字符串\"></a>生成字符串</h5><p>MySQL 6.0中，默认行为是“strict”模式，发生问题时抛出异常，而在早先的服务器版本中，默认方式是截断字符串并发出一个警告。如果希望数据库引擎采取后一种方式，可以将之修改为ANSI模式。</p>\n<ul>\n<li>查看数据库当前模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select @@session.sql_mode;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>改变当前模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set sql_mode=&apos;ansi&apos;;</span><br></pre></td></tr></table></figure>\n<p>==由于服务器是在纯粹字符串时按需分配空间，因此不会因为将varchar列的上限值设的比较大而浪费资源。==</p>\n<ul>\n<li>单引号转义符</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update string_tb1 set text_fld=&apos;This string didn&apos;&apos;t work, but it does now&apos;;</span><br></pre></td></tr></table></figure>\n<p>可以使用单引号作为转义符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update string_tb1 set text_fld=&apos;This string didn\\&apos;t work, but it does now&apos;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>使用内建函数quote()，他用单引号将整个字符串包含起来，并为字符串本身的单引号/撇号增加转义符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select quote(text_fld) </span><br><span class=\"line\">from string_tbl;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>包含特殊字符 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;abcdefg&apos;, CHAR(97,98,99,100,101,102,103);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select CHAR(138,139,140,141,142,143,144,145,146,147);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select concat(&apos;danke sch&apos;, char(148), &apos;n&apos;);</span><br></pre></td></tr></table></figure>\n<p>字符串长度：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select length(char_fld) char_length,</span><br><span class=\"line\">length(vchar_fld) varchar_length,</span><br><span class=\"line\">length(text_fld) text_length </span><br><span class=\"line\">from string_tbl;</span><br></pre></td></tr></table></figure></p>\n<p>字符串位置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select position(&apos;characters&apos; in vchar_fld) </span><br><span class=\"line\">from string_tbl;</span><br></pre></td></tr></table></figure></p>\n<p>如果找不到该子字符串，那么position()函数将返回0.</p>\n<p>从任意位置开始查找字符串位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select locate(&apos;is&apos;, vchar_fld, 5) </span><br><span class=\"line\">froom string_tbl;</span><br></pre></td></tr></table></figure>\n<p>字符串比较（只有mysql）</p>\n<p>mysql的strcmp()大小写不敏感</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select strcmp(&apos;12345&apos;, &apos;abc&apos;) 12345_abc,</span><br><span class=\"line\">strcmp(&apos;abcd&apos;, &apos;xyz&apos;) abcd_xyz,</span><br><span class=\"line\">strcmp(&apos;qrstuv&apos;, &apos;QRSTUV&apos;) qrstuv_QRSTUV;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>like<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,name like &apos;%ns&apos; ends_in_ns </span><br><span class=\"line\">from department;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id, cust_type_cd, fed_id, </span><br><span class=\"line\">fed_id regexp &apos;_&#123;3&#125;-_&#123;2&#125;-_&#123;4&#125;&apos; is_ss_no_format </span><br><span class=\"line\">from customer;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>concat()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update string_tbl </span><br><span class=\"line\">set text_fld = concat(text_fld, &apos;, but now it is longer&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Oracle下，可以使用连接操作符<code>||</code>代替concat()进行字符串连接<br>SQL Server并么有concat()函数，使用的是连接操作符<code>+</code></p>\n<ul>\n<li>插入字符串 insert()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select insert(&apos;goodbye world&apos;, 9, 0, &apos;cruel &apos;) string;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果第三个参数大于0，那么相应数目的字符将会被替换字符串所取代：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select insert(&apos;goodbye world&apos;, 1, 7, &apos;hello&apos;) string;</span><br></pre></td></tr></table></figure>\n<p>Oracle数据没有提供MySQL中的insert()类似函数，但他的replace()函数也可以用于替换字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select replace(&apos;goodbye world&apos;, &apos;goodbye&apos;, &apos;hello&apos;) from dual;</span><br></pre></td></tr></table></figure>\n<p>SQL Server 同样包含replace()函数，除此之外，还包含stuff()函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select stuff(&apos;hello world&apos;, 1, 5, &apos;goodbye cruel&apos;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>子串 substring()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select substring(&apos;goodbye cruel world&apos;, 9, 5);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"使用数值数据\"><a href=\"#使用数值数据\" class=\"headerlink\" title=\"使用数值数据\"></a>使用数值数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select (37 * 59) / (78 - (8 * 6));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select mod(10,4);</span><br><span class=\"line\"></span><br><span class=\"line\">select pow(2, 8);</span><br></pre></td></tr></table></figure>\n<h5 id=\"控制数字经度\"><a href=\"#控制数字经度\" class=\"headerlink\" title=\"控制数字经度\"></a>控制数字经度</h5><ul>\n<li>ceil()</li>\n<li>floor()</li>\n<li>round() 四舍五入，保留n位小数</li>\n<li>truncate() 直接舍掉后面的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ceil(72.445),floor(72.445);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果:<code>73    72</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select round(72.4999),round(72.5);</span><br><span class=\"line\"></span><br><span class=\"line\">select round(72.0909, 1), round(72.0909,2), round(72.0909, 3);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select truncate(72.0909,1), truncate(72.0909,2), truncate(72.0909,3);</span><br></pre></td></tr></table></figure>\n<p>truncate()和round()第二个参数都可以指定为负数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select round(17, -1), truncate(17, -1);</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><code>20  10</code></p>\n<h5 id=\"处理有符号数\"><a href=\"#处理有符号数\" class=\"headerlink\" title=\"处理有符号数\"></a>处理有符号数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, sign(avail_balance), abs(avail_balance) </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>sign()函数取符号</li>\n<li>abs()函数取绝对值</li>\n</ul>\n<h4 id=\"使用时间数据\"><a href=\"#使用时间数据\" class=\"headerlink\" title=\"使用时间数据\"></a>使用时间数据</h4><ul>\n<li>时区设置：全局时区和会话时区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select @@global.time_zone,@@session.time_zone;</span><br></pre></td></tr></table></figure>\n<p>服务器自动将字符串适配到datetime列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update transaction </span><br><span class=\"line\">set txn_date = &apos;2008-09-17 15:30:00&apos; </span><br><span class=\"line\">where txn_id = 99999;</span><br></pre></td></tr></table></figure></p>\n<p>使用cast()函数转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cast(&apos;2008-09-17 15:30:00&apos; as datetime);</span><br><span class=\"line\"></span><br><span class=\"line\">select cast(&apos;2009-09-17&apos; as date) date_field </span><br><span class=\"line\">select cast(&apos;108:17:57&apos; as time) time_field;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>str_to_date()</code>函数  将字符串格式化为日期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update individual </span><br><span class=\"line\">set birth_date = str_to_date(&apos;September 17, 2008&apos;, &apos;%M %d, %Y&apos;) </span><br><span class=\"line\">where cust_id = 9999;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当前日期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select current_date(), current_time(), current_timestamp();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当前日期加上5天 <code>date_add()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select date_add(current_date(), interval 5 day);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update transaction </span><br><span class=\"line\">set txn_date = date_add(txn_date, interval &apos;3:27:11&apos; hour_second) </span><br><span class=\"line\">where txn_id = 9999;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>当月最后一天  <code>last_day()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_day(&apos;2008-09-17&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回某一天是星期几 <code>dayname()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dayname(&apos;2008-09-18&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提取日期值中的信息 <code>extract()</code>函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select extract(year from &apos;2008-09-18 22:19:05&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>时间间隔 <code>datediff()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select datediff(&apos;2009-09-03&apos;, &apos;2009-06-24&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"转换函数\"><a href=\"#转换函数\" class=\"headerlink\" title=\"转换函数\"></a>转换函数</h4><ul>\n<li><code>cast()</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cast(&apos;14567&apos; as signed integer);</span><br></pre></td></tr></table></figure>\n<p>遇到非数字的字符，转换将中止并不返回错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selct cast(&apos;999ABC111&apos; as unsigned integer);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"分组与聚集\"><a href=\"#分组与聚集\" class=\"headerlink\" title=\"分组与聚集\"></a>分组与聚集</h3><ul>\n<li><p>group by</p>\n</li>\n<li><p>分组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分组，并查看每一个分组的数量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>过滤出条数大于4的分组，需要用having，不能用where，因为用where过滤的时候，还未分组</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">having count(*) &gt; 4;</span><br></pre></td></tr></table></figure>\n<h4 id=\"聚集函数\"><a href=\"#聚集函数\" class=\"headerlink\" title=\"聚集函数\"></a>聚集函数</h4><ul>\n<li>Max()</li>\n<li>Min()</li>\n<li>Avg()</li>\n<li>Sum()</li>\n<li>Count()</li>\n</ul>\n<h5 id=\"隐式或显式分组\"><a href=\"#隐式或显式分组\" class=\"headerlink\" title=\"隐式或显式分组\"></a>隐式或显式分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(avail_balance) max_balance,</span><br><span class=\"line\">min(avail_balance) min_balance,</span><br><span class=\"line\">avg(avail_balance) avg_balance,</span><br><span class=\"line\">sum(avail_balance) sum_balance,</span><br><span class=\"line\">count(*) num_accounts </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd = &apos;CHK&apos;;</span><br></pre></td></tr></table></figure>\n<p>上个例子中，查询返回的每个值都是由聚集函数产生的，这些聚集函数作用于使用过滤条件product_cd=’CHK’指定的分组上的所有行。这里没有使用group by子句，因此它是一个隐式分组（即包含查询返回的所有行）。</p>\n<p>但如果同时需要提取product_cd列，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd,</span><br><span class=\"line\">max(avail_balance) max_balance,</span><br><span class=\"line\">min(avail_balance) min_balance,</span><br><span class=\"line\">avg(avail_balance) avg_balance,</span><br><span class=\"line\">sum(avail_balance) sum_balance,</span><br><span class=\"line\">count(*) num_accounts </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure></p>\n<p>将会报错，因为没有显式地指定如何对数据分组。改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd,</span><br><span class=\"line\">max(avail_balance) max_balance,</span><br><span class=\"line\">min(avail_balance) min_balance,</span><br><span class=\"line\">avg(avail_balance) avg_balance,</span><br><span class=\"line\">sum(avail_balance) sum_balance,</span><br><span class=\"line\">count(*) num_accounts </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"对独立值计数\"><a href=\"#对独立值计数\" class=\"headerlink\" title=\"对独立值计数\"></a>对独立值计数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(open_emp_id)</span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure>\n<p>去除重复的行统计：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(distinct open_emp_id) </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"对null的计算\"><a href=\"#对null的计算\" class=\"headerlink\" title=\"对null的计算\"></a>对null的计算</h5><p>count(*) 计算所有行<br>count(val) 会忽略null</p>\n<h4 id=\"产生分组\"><a href=\"#产生分组\" class=\"headerlink\" title=\"产生分组\"></a>产生分组</h4><h5 id=\"单列分组\"><a href=\"#单列分组\" class=\"headerlink\" title=\"单列分组\"></a>单列分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd, sum(avail_balance) prod_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd;</span><br></pre></td></tr></table></figure>\n<h5 id=\"对多列的分组\"><a href=\"#对多列的分组\" class=\"headerlink\" title=\"对多列的分组\"></a>对多列的分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd,open_branch_id, </span><br><span class=\"line\">sum(avail_balance) tot_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd, open_branch_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"利用表达式分组\"><a href=\"#利用表达式分组\" class=\"headerlink\" title=\"利用表达式分组\"></a>利用表达式分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select extract(year form start_date) year,</span><br><span class=\"line\">count(*) how_many </span><br><span class=\"line\">from employee </span><br><span class=\"line\">group by extract(year from start_date);</span><br></pre></td></tr></table></figure>\n<h5 id=\"产生合计数-with-rollup\"><a href=\"#产生合计数-with-rollup\" class=\"headerlink\" title=\"产生合计数 with rollup\"></a>产生合计数 with rollup</h5><ul>\n<li>独立产品也进行合计，最后还会产生总的合计</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd, open_branch_id,</span><br><span class=\"line\">sum(avail_balance) tot_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd, open_branch_id with rollup;</span><br></pre></td></tr></table></figure>\n<h4 id=\"分组过滤条件\"><a href=\"#分组过滤条件\" class=\"headerlink\" title=\"分组过滤条件\"></a>分组过滤条件</h4><ul>\n<li>分组前——用where过滤</li>\n<li>分组后——用having过滤</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd, sum(avail_balance) prod_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where status = &apos;ACTIVE&apos; </span><br><span class=\"line\">group by product_cd </span><br><span class=\"line\">having sum(avail_balance) &gt;=10000;</span><br></pre></td></tr></table></figure>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_id,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_emp_id &lt;&gt; (select e.emp_id </span><br><span class=\"line\">from employee e inner join branch b </span><br><span class=\"line\">on e.assigned_branch_id = b.branch_id </span><br><span class=\"line\">where e.title = &apos;Head Teller&apos; and b.city = &apos;Woburn&apos;);</span><br></pre></td></tr></table></figure>\n<p>上述子查询只有一个结果，否则会报错。</p>\n<h5 id=\"多行单列子查询\"><a href=\"#多行单列子查询\" class=\"headerlink\" title=\"多行单列子查询\"></a>多行单列子查询</h5><ul>\n<li>in 和 not in运算分<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select branch_id, name, city </span><br><span class=\"line\">from branch </span><br><span class=\"line\">where name in (&apos;Headquarters&apos;, &apos;Quincy Branch&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>查询所有主管：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where emp_id in (select superior_emp_id </span><br><span class=\"line\">from employee);</span><br></pre></td></tr></table></figure></p>\n<p>查询所有不管理别人的雇员：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where emp_id not in (select superior_emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where superior_emp_id is not null);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>all运算符<br>将某单值与集合中的每个值进行比较：</p>\n<p>查询非主管雇员：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where emp_id &lt;&gt; all (select superior_emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where superior_emp_id is not null);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==当使用not in或&lt;&gt;运算符比较一个值和一个值集时，必须确保值集中不包含null值，因为服务器将表达式左边的值与null比较时，都将产生未知的结果。==</p>\n<ul>\n<li>any运算符</li>\n</ul>\n<p>any运算符只要有一个比较成立，则条件为真。all需要都成立才为真。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,cust_id,product_cd, avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where avail_balance &gt; any (select a.avail_balance </span><br><span class=\"line\">from account a inner join individual i </span><br><span class=\"line\">on a.cust_id = i.cust_id </span><br><span class=\"line\">where i.fname = &apos;Frank&apos; and i.lname = &apos;Tucker&apos;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"多列子查询\"><a href=\"#多列子查询\" class=\"headerlink\" title=\"多列子查询\"></a>多列子查询</h5><ul>\n<li>多重单列子查询：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, product_id, cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = (select branch_id </span><br><span class=\"line\">from branch </span><br><span class=\"line\">where name = &apos;Woburn Branch&apos;) </span><br><span class=\"line\">and open_emp_id in (select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where title = &apos;Teller&apos; or title = &apos;Head Teller&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等同于下面的 多列子查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, product_id, cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where (open_branch_id, open_emp_id) in </span><br><span class=\"line\">(select b.branch_id, e.emp_id </span><br><span class=\"line\">from branch b inner join employee e </span><br><span class=\"line\">on b.branch_id = e.assigned_branch_id </span><br><span class=\"line\">where b.name = &apos;Woburn Branch&apos; </span><br><span class=\"line\">and (e.title = &apos;Teller&apos; or e.title = &apos;Head Teller&apos;));</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"关联子查询\"><a href=\"#关联子查询\" class=\"headerlink\" title=\"关联子查询\"></a>关联子查询</h4><p>子查询最后引用的c.cust_id使之具有关联性，这样他的执行必须依赖于包含查询提供的c.cust_id。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.cust_type_cd, c.city </span><br><span class=\"line\">from customer c </span><br><span class=\"line\">where 2 = (select count(*) </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where a.cust_id = c.cust_id);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.cust_type_cd, c.city</span><br><span class=\"line\">from customer c </span><br><span class=\"line\">where (select sum(a.avail_balance) </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where a.cust_id = c.cust_id)</span><br><span class=\"line\">between 5000 and 10000;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;ALTER! : Account #1 Hs Incorrect Balance!&apos; </span><br><span class=\"line\">from account </span><br><span class=\"line\">where (avail_balance, pending_balance) &lt;&gt; ¡™</span><br><span class=\"line\">(select sum(&lt;expression to generate available balance&gt;), </span><br><span class=\"line\">sum(&lt;expression to generate pending balance&gt;) </span><br><span class=\"line\">from transaction </span><br><span class=\"line\">where account_id = 1) </span><br><span class=\"line\">and account_id = 1;</span><br></pre></td></tr></table></figure>\n<p>对于上面的例子，用关联子查询代替非关联子查询，升级为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;ALTER! : Account #1 Hs Incorrect Balance!&apos; </span><br><span class=\"line\">from account t </span><br><span class=\"line\">where (avail_balance, pending_balance) &lt;&gt; </span><br><span class=\"line\">(select sum(&lt;expression to generate available balance&gt;), </span><br><span class=\"line\">sum(&lt;expression to generate pending balance&gt;) </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"exists-运算符\"><a href=\"#exists-运算符\" class=\"headerlink\" title=\"exists 运算符\"></a>exists 运算符</h5><p>exists运算符是构造包含关联子查询条件最常用的运算符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, a.cust_id, a.avail_balance </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where exists (select 1 </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id </span><br><span class=\"line\">and t.txn_date = &apos;2008-09-22&apos;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>not exists</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, a.cust_id </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where not exists (select 1 </span><br><span class=\"line\">from business b </span><br><span class=\"line\">where b.cust_id = a.cust_id);</span><br></pre></td></tr></table></figure>\n<h5 id=\"关联子查询操作数据\"><a href=\"#关联子查询操作数据\" class=\"headerlink\" title=\"关联子查询操作数据\"></a>关联子查询操作数据</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update account a </span><br><span class=\"line\">set a.last_activity_date = </span><br><span class=\"line\">(select max(t.txn_date) </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id);</span><br></pre></td></tr></table></figure>\n<p>但是上面的子查询语句没有检查每个账户是否发生过交易，否则有可能为null，因此修改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update account a </span><br><span class=\"line\">set a.last_activity_date = </span><br><span class=\"line\">(select max(t.txn_date) </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id) </span><br><span class=\"line\">where exists (select 1 </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id);</span><br></pre></td></tr></table></figure></p>\n<p>删除没有员工的部门：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from department </span><br><span class=\"line\">where not exists (select 1 </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where employee.dept_id = department.dept_id);</span><br></pre></td></tr></table></figure>\n<p>==注：在MySQL中delete语句使用关联子查询时，不能使用表别名。==</p>\n<p>查找开户数最多的雇员：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">having count(*) = (select max(emp_cnt.how_many) </span><br><span class=\"line\">from (select count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id) emp_cnt);</span><br></pre></td></tr></table></figure>\n<p>检索雇员数据，排序第一准则是老板姓氏，第二是雇员的姓氏：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp.emp_id, concat(emp.fname, &apos; &apos;, emp.lname) emp_name, </span><br><span class=\"line\">(select concat(boss.fname, &apos; &apos;, boss.lname) </span><br><span class=\"line\">from employee boss </span><br><span class=\"line\">where boss.emp_id = emp.superior_emp_id) boss_name </span><br><span class=\"line\">from employee emp </span><br><span class=\"line\">where emp.superior_emp_id is not null </span><br><span class=\"line\">order by (select boss.lname from employee boss </span><br><span class=\"line\">where boss.emp_id = emp.superior_emp_id), emp.lname;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"再谈连接\"><a href=\"#再谈连接\" class=\"headerlink\" title=\"再谈连接\"></a>再谈连接</h3><h4 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.cust_id, b.name </span><br><span class=\"line\">from account a left outer join business b </span><br><span class=\"line\">on a.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"左外连接与右外连接\"><a href=\"#左外连接与右外连接\" class=\"headerlink\" title=\"左外连接与右外连接\"></a>左外连接与右外连接</h5><p>left指连接左边的表决定结果集的行数，而右边只负责提供与之匹配的列值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id,b.name </span><br><span class=\"line\">from customer c left outer join business b </span><br><span class=\"line\">on c.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure></p>\n<p>如果是右链接：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id,b.name </span><br><span class=\"line\">from customer c right outer join busines b </span><br><span class=\"line\">where c.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"三路外连接\"><a href=\"#三路外连接\" class=\"headerlink\" title=\"三路外连接\"></a>三路外连接</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, </span><br><span class=\"line\">concat(i.fname, &apos; &apos;, i.lname) person_name,</span><br><span class=\"line\">b.name business_name </span><br><span class=\"line\">from account a left outer join individual i </span><br><span class=\"line\">on a.cust_id = i.cust_id </span><br><span class=\"line\">left outer join business b </span><br><span class=\"line\">on a.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure>\n<p>如果mysql对于外连接到同一个表的其他表的树木有限制，那么可以这么重写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_ind.account_id, account_ind.product_cd,</span><br><span class=\"line\">account_ind.person_name,</span><br><span class=\"line\">b.name business_name </span><br><span class=\"line\">from </span><br><span class=\"line\">(select a.account_id, a.product_cd, a.cust_id, </span><br><span class=\"line\">concat(i.fname, &apos; &apos;, i.lname) person name </span><br><span class=\"line\">from account a left outer join individual i </span><br><span class=\"line\">on a.cust_id = i.cust_id) account_ind </span><br><span class=\"line\">left outer join business b </span><br><span class=\"line\">on account_ind.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"自外连接\"><a href=\"#自外连接\" class=\"headerlink\" title=\"自外连接\"></a>自外连接</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname, e.lname,</span><br><span class=\"line\">e_mgr.fname mgr_fname, e_mgr.lname mgr_lname </span><br><span class=\"line\">from employee e left outer join employee e_mgr </span><br><span class=\"line\">on e.superior_emp_id = e_mgr.emp_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select pt.name, p.product_cd, p.name </span><br><span class=\"line\">from product p cross join product_type pt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成2008年全年日期<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select date_add(&apos;2008-01-01&apos;, interval (ones.num + tens.num + hundreds.num) day) dt  </span><br><span class=\"line\">from </span><br><span class=\"line\">(select 0 num union all </span><br><span class=\"line\">select 1 num union all </span><br><span class=\"line\">select 2 num union all </span><br><span class=\"line\">select 3 num union all </span><br><span class=\"line\">select 4 num union all </span><br><span class=\"line\">select 5 num union all </span><br><span class=\"line\">select 6 num union all </span><br><span class=\"line\">select 7 num union all </span><br><span class=\"line\">select 8 num union all </span><br><span class=\"line\">select 9 num) ones </span><br><span class=\"line\">cross join </span><br><span class=\"line\">(select 0 num union all </span><br><span class=\"line\">select 10 num union all </span><br><span class=\"line\">select 20 num union all </span><br><span class=\"line\">select 30 num union all </span><br><span class=\"line\">select 40 num union all </span><br><span class=\"line\">select 50 num union all </span><br><span class=\"line\">select 60 num union all </span><br><span class=\"line\">select 70 num union all </span><br><span class=\"line\">select 80 num union all </span><br><span class=\"line\">select 90 num) tens  </span><br><span class=\"line\">cross join </span><br><span class=\"line\">(select 0 num union all </span><br><span class=\"line\">select 100 num union all </span><br><span class=\"line\">select 200 num union all </span><br><span class=\"line\">select 300 num) hundreds </span><br><span class=\"line\">where date_add(&apos;2008-01-01&apos;, </span><br><span class=\"line\">interval(ones.num+tens.num+hundreds.num) day) &lt; &apos;2009-01-01&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==order by 1表示根据第一列的值自然排序。==</p>\n<h4 id=\"自然连接\"><a href=\"#自然连接\" class=\"headerlink\" title=\"自然连接\"></a>自然连接</h4><p>要避免不要使用自然连接。</p>\n<h3 id=\"条件逻辑\"><a href=\"#条件逻辑\" class=\"headerlink\" title=\"条件逻辑\"></a>条件逻辑</h3><ul>\n<li>根据cust_type_cd字段判断决定使用indiv_name还是business_name列的值：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.fed_id,</span><br><span class=\"line\">case </span><br><span class=\"line\">when c.cust_type_cd = &apos;I&apos; </span><br><span class=\"line\">then concat(i.fname, &apos; &apos;, i.lname) </span><br><span class=\"line\">when c.cust_type_cd = &apos;B&apos; </span><br><span class=\"line\">then b.name </span><br><span class=\"line\">else &apos;Unknown&apos; </span><br><span class=\"line\">end name </span><br><span class=\"line\">from customer c left outer join individual i </span><br><span class=\"line\">on c.cust_id = i.cust_id </span><br><span class=\"line\">left outer join business b </span><br><span class=\"line\">on c.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"case表达式\"><a href=\"#case表达式\" class=\"headerlink\" title=\"case表达式\"></a>case表达式</h4><h5 id=\"查找型case表达式\"><a href=\"#查找型case表达式\" class=\"headerlink\" title=\"查找型case表达式\"></a>查找型case表达式</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CASE </span><br><span class=\"line\">    WHEN C1 THEN E1 </span><br><span class=\"line\">    WHEN C2 THEN E2 </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    WHEN CN THEN CN </span><br><span class=\"line\">    [ELSE ED] </span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n<p>上面的语句可以改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.fed_id,</span><br><span class=\"line\">case</span><br><span class=\"line\">    when c.cust_type_cd = &apos;I&apos; then </span><br><span class=\"line\">    (select concat(i.fname, &apos; &apos;, i.lname) </span><br><span class=\"line\">    from individual i </span><br><span class=\"line\">    where i.cust_id = c.cust_id) </span><br><span class=\"line\">    when c.cust_type_cd = &apos;B&apos; then </span><br><span class=\"line\">    (select b.name </span><br><span class=\"line\">    from business b </span><br><span class=\"line\">    where b.cust_id = c.cust_id) </span><br><span class=\"line\">    else &apos;Unknown&apos; </span><br><span class=\"line\">    end name </span><br><span class=\"line\">from customer c;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"结果集变换\"><a href=\"#结果集变换\" class=\"headerlink\" title=\"结果集变换\"></a>结果集变换</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select year(open_date) year, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_date &gt; &apos;1999-12-31&apos; </span><br><span class=\"line\">and open_date &lt; &apos;2006-01-01&apos; </span><br><span class=\"line\">group by year(open_date);</span><br></pre></td></tr></table></figure>\n<p>结果是6行，如果想要变换成单行6列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2000 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2000,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2001 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2001,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2002 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2002,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2003 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2003,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2004 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2004,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2005 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2005</span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_date &gt; &apos;1999-12-31&apos; and open_date &lt; &apos;2006-01-01&apos;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"存在性检查\"><a href=\"#存在性检查\" class=\"headerlink\" title=\"存在性检查\"></a>存在性检查</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.fed_id, c.cust_type_cd,</span><br><span class=\"line\">    case </span><br><span class=\"line\">        when exists (select 1 from account a </span><br><span class=\"line\">        where a.cust_id = c.cust_id </span><br><span class=\"line\">        and a.product_cd = &apos;CHK&apos;) then &apos;Y&apos; </span><br><span class=\"line\">        else &apos;N&apos; </span><br><span class=\"line\">    end has_checking,</span><br><span class=\"line\">    case</span><br><span class=\"line\">        when exists (select 1 froom account a </span><br><span class=\"line\">        where a.cust_id = c.cust_id </span><br><span class=\"line\">        and a.product_cd = &apos;SAV&apos;) then &apos;Y&apos; </span><br><span class=\"line\">        else &apos;N&apos; </span><br><span class=\"line\">    end has_savings </span><br><span class=\"line\">from customer c;</span><br></pre></td></tr></table></figure>\n<h5 id=\"除零错误\"><a href=\"#除零错误\" class=\"headerlink\" title=\"除零错误\"></a>除零错误</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.cust_id, a.product_cd, a.avail_balance / </span><br><span class=\"line\"> case</span><br><span class=\"line\">  when prod_tots.tot_balance = 0 then 1 </span><br><span class=\"line\">  else prod_tots.tot_balance </span><br><span class=\"line\"> end percent_of_total </span><br><span class=\"line\">from account a inner join </span><br><span class=\"line\">(select a.product_cd, sum(a.avail_balance) tot_balance </span><br><span class=\"line\">from account a </span><br><span class=\"line\">group by a.product_cd) prod_tots </span><br><span class=\"line\">on a.product_cd = prod_tots.product_cd;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><h4 id=\"多用户数据库\"><a href=\"#多用户数据库\" class=\"headerlink\" title=\"多用户数据库\"></a>多用户数据库</h4><h5 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h5><p>两种锁……</p>\n<ul>\n<li>==写锁+读锁==</li>\n<li>写锁，读取不需要锁。服务器要保证从查询开始到结束读操作看到一个一致的数据视图，这个方法被称为==版本控制==。</li>\n</ul>\n<h5 id=\"锁的粒度\"><a href=\"#锁的粒度\" class=\"headerlink\" title=\"锁的粒度\"></a>锁的粒度</h5><ul>\n<li>表锁</li>\n<li>页锁（阻止多用户同时修改某表中同一页（一页通常是一段2～16KB的内存空间）的数据）</li>\n<li>行锁</li>\n</ul>\n<p><strong>显式启动事务</strong>：</p>\n<ul>\n<li><p>SQL Server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">begin transaction</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MySQL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start transaction</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>关闭自动提交：</strong></p>\n<ul>\n<li>SQL Server</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set implicit_transactions on</span><br></pre></td></tr></table></figure>\n<ul>\n<li>MySQL<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit=0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于SQL Server和MySQL，默认自动提交模式，直到显示启动一个事务。</p>\n<p>一旦离开了自动提交模式，所有的SQL命令都会发生在同一个事务的范围，并且必须显式地对事务进行提交或回滚。</p>\n<h5 id=\"结束事务\"><a href=\"#结束事务\" class=\"headerlink\" title=\"结束事务\"></a>结束事务</h5><ul>\n<li>commit</li>\n<li>rollback</li>\n</ul>\n<p>除了提交commit或rollback指令，结束事务还可以有其他情景触发：</p>\n<ul>\n<li>服务器宕机</li>\n<li>提交一个SQL模式语句，比如alter table，这将会引起当前事务提交和一个新事务启动</li>\n<li>提交另一个start transaction命令，将会引起前一个事务提交</li>\n<li>因为服务器监测到一个死锁，并确定当前事务是罪魁祸首，服务器将会结束当前事务。这种情况下，事务将会被回滚，同时释放错误消息（大多数情况喜爱，终止的事务可以重启，如果没有再次遇到另一个死锁情况他将会成功）</li>\n</ul>\n<h5 id=\"事务保存点\"><a href=\"#事务保存点\" class=\"headerlink\" title=\"事务保存点\"></a>事务保存点</h5><p>6.0版的MySQL包括以下存储引擎：</p>\n<ul>\n<li>MyISAM    表级锁定的非事务引擎</li>\n<li>MEMORY    内存表使用的非事务引擎</li>\n<li>BDB       页级锁定的事务引擎</li>\n<li>InnoDB    行级锁定的事务引擎</li>\n<li>Merge     使多个相同的MyISAM看起来像一个单表（也叫表分割）的专用引擎</li>\n<li>Maria     6.0.6版本中MyISAM的替代品，他添加了充分的恢复功能</li>\n<li>Falcon    6.0.4版本起引入的采用行级锁定的高性能事务引擎</li>\n<li>Archive   用于存储大量未检索数据的专用引擎，主要用来存档</li>\n</ul>\n<p>查看引擎：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show table status like &apos;transaction&apos; \\G</span><br></pre></td></tr></table></figure></p>\n<p>设置引擎：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table transaction engine = innodb;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>创建保存点</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">savepoint my_savepoint;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>回滚到保存点</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rollback to savepoint my_savepoint;</span><br></pre></td></tr></table></figure>\n<h3 id=\"索引和约束\"><a href=\"#索引和约束\" class=\"headerlink\" title=\"索引和约束\"></a>索引和约束</h3><h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><p>索引是一种以特定顺序保存的专用表。</p>\n<h5 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table department </span><br><span class=\"line\">add index dept_name_idx (name);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看索引<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show index from department \\G</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>创建表时的包含一个约束，该约束将primary key dept_id列作为主关键字。</p>\n<ul>\n<li><p>删除索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table department </span><br><span class=\"line\">drop index dept_name_idx;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>唯一索引</strong></p>\n</li>\n</ul>\n<p>设计数据库时，需要考虑哪些列能包含重复数据，哪些列不能。<br>例如department表中不能出现两个相同名字的部门。可以通过department.name创建唯一索引限制出现重复部门名字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table department </span><br><span class=\"line\">add unique dept_name_idx (name);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>多列索引</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table employee </span><br><span class=\"line\">add index emp_names_idx (lname, fname);</span><br></pre></td></tr></table></figure>\n<p>创建多列索引时，必须考虑哪一列作为第一列，哪一列作为第二列，这样索引才会尽可能的有用。</p>\n<h5 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h5><ul>\n<li><strong>B树索引</strong></li>\n</ul>\n<p>平衡树索引</p>\n<p>MySQL、Oracle、SQL Server默认都是B树索引。</p>\n<p>当向表中插入、更新和删除行时，服务器会尽力保持树的平衡。</p>\n<ul>\n<li><strong>位图索引</strong></li>\n</ul>\n<p>位图索引通常应用于数据仓库环境，那里有大量数据被索引，那些列却只包含相对少的值（比如销售岗位、地理环境、产品、销售员）</p>\n<ul>\n<li><strong>文本索引</strong></li>\n</ul>\n<p>MySQL、SQL Server   全文索引<br>Oracle              Oracle Text</p>\n<h5 id=\"如何使用索引\"><a href=\"#如何使用索引\" class=\"headerlink\" title=\"如何使用索引\"></a>如何使用索引</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain select cust_id, sum(avail_balance) tot_bal </span><br><span class=\"line\">from account </span><br><span class=\"line\">where cust_id in (1,5,9,11) </span><br><span class=\"line\">group by cust_id \\G</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">           id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: account</span><br><span class=\"line\">   partitions: NULL</span><br><span class=\"line\">         type: index</span><br><span class=\"line\">possible_keys: fk_a_cust_id</span><br><span class=\"line\">          key: fk_a_cust_id</span><br><span class=\"line\">      key_len: 4</span><br><span class=\"line\">          ref: NULL</span><br><span class=\"line\">         rows: 24</span><br><span class=\"line\">     filtered: 33.33</span><br><span class=\"line\">        Extra: Using where</span><br><span class=\"line\">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<p>优化，给cust_id和avail_balance两列添加新索引：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table account </span><br><span class=\"line\">add index acc_bal_idx (cust_id, avail_balance);</span><br></pre></td></tr></table></figure></p>\n<p>再次查询优化器是如何处理的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain select cust_id, sum(avail_balance) tot_bal </span><br><span class=\"line\">from account </span><br><span class=\"line\">where cust_id in (1,5,9,11) </span><br><span class=\"line\">group by cust_id \\G</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">           id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: account</span><br><span class=\"line\">   partitions: NULL</span><br><span class=\"line\">         type: range</span><br><span class=\"line\">possible_keys: acc_bal_idx</span><br><span class=\"line\">          key: acc_bal_idx</span><br><span class=\"line\">      key_len: 4</span><br><span class=\"line\">          ref: NULL</span><br><span class=\"line\">         rows: 8</span><br><span class=\"line\">     filtered: 100.00</span><br><span class=\"line\">        Extra: Using where; Using index</span><br><span class=\"line\">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>==优化器使用了新索引，而不是fk_a_cust_id==</li>\n<li>==优化器预期只需要8行，而不是24行==</li>\n<li>==不需要account表即可满足查询结果（使用附加列的索引指定）==</li>\n</ul>\n<h5 id=\"索引的不足\"><a href=\"#索引的不足\" class=\"headerlink\" title=\"索引的不足\"></a>索引的不足</h5><ul>\n<li>每个索引其实 都是一个表</li>\n<li>每次在对表添加或删除行时，表中的所有索引必须被修改，当更新行时，受到影响的列的任何索引也必须被修改。</li>\n<li>索引越多，服务器就需要做越多的工作来保持所有模式对象最新。</li>\n</ul>\n<p>默认策略：</p>\n<ul>\n<li>==确保所有的主键列被索引==（大部分服务器会在创建主键约束时自动生成唯一索引），针对多列主键，考虑为主键列的子集构建附加索引，或者以与主键约束定义不同的顺序为所有主键列另外生成索引</li>\n<li>==为所有被外键约束引用的列创建索引。== 服务器在准备删除父行时会查找以确保没有子行存在，为此他必须发出一个查询搜索列中的特定值，如果该列没有索引，那么服务器必须扫描整个表</li>\n<li>==索引那些被频繁检索的列。除了短字符串（3～50个字符）列，大多数日期列也是不错的候选==</li>\n</ul>\n<h4 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h4><ul>\n<li>主键约束</li>\n<li>外键约束</li>\n<li>唯一约束</li>\n<li>检查约束</li>\n</ul>\n<p><strong>创建约束</strong><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> product </span><br><span class=\"line\">(product_cd <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\"><span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">product_type_cd <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">date_offered <span class=\"built_in\">date</span>,</span><br><span class=\"line\">date_retired <span class=\"built_in\">date</span>,</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> fk_product_type_cd <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> (product_type_cd) </span><br><span class=\"line\"><span class=\"keyword\">references</span> product_type (product_type_cd) ,</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> pk_product primary <span class=\"keyword\">key</span> (product_cd)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"约束与索引\"><a href=\"#约束与索引\" class=\"headerlink\" title=\"约束与索引\"></a>约束与索引</h5><p>MySQL 主键约束、外键约束和唯一约束时，都会生成索引。</p>\n<h5 id=\"级联约束\"><a href=\"#级联约束\" class=\"headerlink\" title=\"级联约束\"></a>级联约束</h5><ul>\n<li>on updae cascade</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> product </span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> fk_product_type_cd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> product </span><br><span class=\"line\"><span class=\"keyword\">add</span> <span class=\"keyword\">constraint</span> fk_product_type_cd <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> (product_type_cd) </span><br><span class=\"line\"><span class=\"keyword\">references</span> product_type (product_type_cd) </span><br><span class=\"line\"><span class=\"keyword\">on</span> <span class=\"keyword\">update</span> <span class=\"keyword\">cascade</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>on delete cascade</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table product </span><br><span class=\"line\">add constraint fk_product_type_cd foreign key (product_type_cd) </span><br><span class=\"line\">references product_type (product_type_cd) </span><br><span class=\"line\">on update cascade </span><br><span class=\"line\">on delete cascade;</span><br></pre></td></tr></table></figure>\n<h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3><p>创建视图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view customer_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">fed_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">zipcode</span><br><span class=\"line\">)</span><br><span class=\"line\">as</span><br><span class=\"line\">select cust_id,</span><br><span class=\"line\">concat(&apos;ends in &apos;, substr(fed_id,8,4)) fed_id, </span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">postal_code</span><br><span class=\"line\">from customer;</span><br></pre></td></tr></table></figure></p>\n<p>使用视图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id, fed_id, cust_type_cd </span><br><span class=\"line\">from customer_vw;</span><br></pre></td></tr></table></figure></p>\n<p>服务器真正执行的查询是将两者合并创建的一个新查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,</span><br><span class=\"line\">concat(&quot;ends in &quot;, substr(fed_id,8,4)) fed_id,</span><br><span class=\"line\">cust_type_cd </span><br><span class=\"line\">from customer;</span><br></pre></td></tr></table></figure></p>\n<p>查看视图有哪些列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe customer_vw;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cst.cust_id, cst.fed_id, bus.name </span><br><span class=\"line\">from customer_vw cst inner join business bus </span><br><span class=\"line\">on cst.cust_id = bus.cust_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么使用视图\"><a href=\"#为什么使用视图\" class=\"headerlink\" title=\"为什么使用视图\"></a>为什么使用视图</h4><h5 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h5><p>只能查询企业用户：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view business_customer_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">fed_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">zipcode</span><br><span class=\"line\">) </span><br><span class=\"line\">as </span><br><span class=\"line\">select cust_id,</span><br><span class=\"line\">concat(&apos;ends in &apos;, substr(fed_id, 8, 4)) fed_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">postal_code </span><br><span class=\"line\">from customer </span><br><span class=\"line\">where cust_type_cd = &apos;B&apos;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"数据聚合\"><a href=\"#数据聚合\" class=\"headerlink\" title=\"数据聚合\"></a>数据聚合</h5><p>生成报表展示账户数据和每个客户的储蓄总额：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view customer_totals_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">cust_name,</span><br><span class=\"line\">num_accounts,</span><br><span class=\"line\">tot_deposits) </span><br><span class=\"line\">as </span><br><span class=\"line\">select cst.cust_id, cst.cust_type_cd,</span><br><span class=\"line\"> case </span><br><span class=\"line\">  when cst.cust_type_cd = &apos;B&apos; then </span><br><span class=\"line\">  (select bus.name from business bus where bus.cust_id = cst.cust_id) </span><br><span class=\"line\">  else </span><br><span class=\"line\">  (select concat(ind.fname, &apos; &apos;, ind.lname) </span><br><span class=\"line\">  from individual ind </span><br><span class=\"line\">  where ind.cust_id = cst.cust_id) </span><br><span class=\"line\"> end cust_name,</span><br><span class=\"line\"> sum(case when act.status = &apos;ACTIVE&apos; then 1 else 0 end) tot_active_accounts,</span><br><span class=\"line\"> sum(case when act.status = &apos;ACTIVE&apos; then act.avail_balance else 0 end) tot_balance </span><br><span class=\"line\">from customer cst inner join account act </span><br><span class=\"line\">on act.cust_id = cst.cust_id </span><br><span class=\"line\">group by cst.cust_id, cst.cust_type_cd;</span><br></pre></td></tr></table></figure></p>\n<p>决定将数据预聚合到一个表中而不是利用视图总计，那么可以先创建customer_totals表，然后修改视图customer_totals_vw定义，再从该表中检索数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table customer_totals  </span><br><span class=\"line\">as </span><br><span class=\"line\">select * from customer_totals_vw;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create or replace view customer_totals_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">cust_name,</span><br><span class=\"line\">num_accounts,</span><br><span class=\"line\">tot_deposits</span><br><span class=\"line\">) </span><br><span class=\"line\">as </span><br><span class=\"line\">select cust_id, cust_type_cd, cust_name, num_accounts, tot_deposits </span><br><span class=\"line\">from customer_totals;</span><br></pre></td></tr></table></figure>\n<h5 id=\"隐藏复杂性\"><a href=\"#隐藏复杂性\" class=\"headerlink\" title=\"隐藏复杂性\"></a>隐藏复杂性</h5><h5 id=\"连接分区数据\"><a href=\"#连接分区数据\" class=\"headerlink\" title=\"连接分区数据\"></a>连接分区数据</h5><p>transaction变的越来越大，那么设计者可以将其分为两个表：transaction_current,transaction_historic。然后可以通过视图将两个表联合起来：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view transaction_vw </span><br><span class=\"line\">(txn_date,</span><br><span class=\"line\">account_id,</span><br><span class=\"line\">txn_type_cd,</span><br><span class=\"line\">amount,</span><br><span class=\"line\">teller_emp_id,</span><br><span class=\"line\">execution_branch_id,</span><br><span class=\"line\">funds_avail_date</span><br><span class=\"line\">) </span><br><span class=\"line\">as </span><br><span class=\"line\">select txn_date, account_id, txn_type_cd, amount, teller_emp_id, </span><br><span class=\"line\">execution_branch_id, funds_avail_date </span><br><span class=\"line\">from transaction_historic </span><br><span class=\"line\">union all </span><br><span class=\"line\">select txn_date, account_id, txn_type_cd, amount, teller_emp_id, </span><br><span class=\"line\">execution_branch_id, funds_avail_date </span><br><span class=\"line\">from transaction_current;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"可更新的视图\"><a href=\"#可更新的视图\" class=\"headerlink\" title=\"可更新的视图\"></a>可更新的视图</h4><p>对于MySQL，如果以下条件能满足，那么视图就是可更新的：</p>\n<ul>\n<li>没有使用聚合函数，例如max()、min()、avg() 等</li>\n<li>视图没有使用group by或having子句</li>\n<li>select或from子句中不存在子查询，并且where子句中的任何子查询都不引用from子句中的表</li>\n<li>视图没有使用union、union all和distinct</li>\n<li>from子句包括不止一个表或可更新视图</li>\n<li>如果有不止一个表或视图，那么from子句只使用内连接</li>\n</ul>\n<p>修改视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update customer_vw </span><br><span class=\"line\">set city = &apos;Woooburn&apos; </span><br><span class=\"line\">where city =  &apos;Woburn&apos;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h3><ul>\n<li>元数据——数据的数据</li>\n<li>数据字典或者系统目录</li>\n</ul>\n<h4 id=\"信息模式\"><a href=\"#信息模式\" class=\"headerlink\" title=\"信息模式\"></a>信息模式</h4><ul>\n<li>==information_schema数据库==里所有可用对象是视图</li>\n</ul>\n<p>检索bank数据库里所有表的名字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select table_name, table_type </span><br><span class=\"line\">from information_schema.tables </span><br><span class=\"line\">where table_schema = &apos;bank&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure></p>\n<p>在结果中排除视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select table_name, table_type </span><br><span class=\"line\">from information_schema.tables </span><br><span class=\"line\">where table_schema = &apos;bank&apos; and table_type = &apos;BASE TABLE&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure></p>\n<p>只检索视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select table_name,is_updatable </span><br><span class=\"line\">from information_schema.views </span><br><span class=\"line\">where table_schema=&apos;bank&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure></p>\n<p>查看表的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select column_name,data_type,character_maximum_length char_max_len,</span><br><span class=\"line\">numeric_precision num_prcsn, numeric_scale num_scale </span><br><span class=\"line\">from infromation_schema.columns </span><br><span class=\"line\">where table_schema=&apos;bank&apos; and table_name=&apos;account&apos; </span><br><span class=\"line\">order by ordinal_position;</span><br></pre></td></tr></table></figure></p>\n<p>查询表中的索引信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select index_name,non_unique,seq_in_index,column_name </span><br><span class=\"line\">from information_schema.statistics </span><br><span class=\"line\">where table_schema = &apos;bank&apos; and table_name = &apos;account&apos; </span><br><span class=\"line\">order by 1,3;</span><br></pre></td></tr></table></figure></p>\n<p>查询bank模式中的所有视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select constraint_name,table_name,constraint_type </span><br><span class=\"line\">from information_schema.table_constraints </span><br><span class=\"line\">where table_schema = &apos;bank&apos; </span><br><span class=\"line\">order by 3,1;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用元数据\"><a href=\"#使用元数据\" class=\"headerlink\" title=\"使用元数据\"></a>使用元数据</h4><h5 id=\"模式生成脚本\"><a href=\"#模式生成脚本\" class=\"headerlink\" title=\"模式生成脚本\"></a>模式生成脚本</h5><h5 id=\"生成动态SQL\"><a href=\"#生成动态SQL\" class=\"headerlink\" title=\"生成动态SQL\"></a>生成动态SQL</h5><p>MySQL为动态SQL执行提供了：</p>\n<ul>\n<li>prepare</li>\n<li>execute</li>\n<li>deallocate<br>语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--将sql语句赋给变量qry</span><br><span class=\"line\">set @qry = &apos;select cust_id, cust_type_cd, fed_id from customer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">-- qry被prepare语句提交给数据库引擎（解析、安全检查、优化）</span><br><span class=\"line\">prepare dynsql1 from @qry;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 执行</span><br><span class=\"line\">execute dynsql1;</span><br><span class=\"line\"></span><br><span class=\"line\">-- deallocate prepare关闭语句，释放执行中使用的所有数据库资源（如游标）</span><br><span class=\"line\">deallocate prepare dynsql1;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 查询包含占位符</span><br><span class=\"line\">set @qry = &apos;select product_cd, name, product_type_cd, date_offered, date_retired from product where product_cd = ?&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">prepare dynsql2 from @qry;</span><br><span class=\"line\"></span><br><span class=\"line\">set @prodcd = &apos;CKH&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">execute dynsql2 using @prodcd;</span><br><span class=\"line\"></span><br><span class=\"line\">set @prodcd = &apos;SAV&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">execute dynsql2 usging @prodcd;</span><br><span class=\"line\"></span><br><span class=\"line\">deallocate prepare dynsql2;</span><br></pre></td></tr></table></figure>\n<p>可以通过使用元数据生成动态SQL查询语句，而不是使用上面的硬编码。</p>\n<h3 id=\"MySQL对SQL语言的扩展\"><a href=\"#MySQL对SQL语言的扩展\" class=\"headerlink\" title=\"MySQL对SQL语言的扩展\"></a>MySQL对SQL语言的扩展</h3><h4 id=\"limit子句\"><a href=\"#limit子句\" class=\"headerlink\" title=\"limit子句\"></a>limit子句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">limit 3;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组合limit子句和order by子句<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">order by how_many desc </span><br><span class=\"line\">limit 3;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">order by how_many desc </span><br><span class=\"line\">limit 2,1;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">order by how_many desc </span><br><span class=\"line\">limit 2,999999999;</span><br></pre></td></tr></table></figure>\n<h5 id=\"into-outfile子句\"><a href=\"#into-outfile子句\" class=\"headerlink\" title=\"into outfile子句\"></a>into outfile子句</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, start_date </span><br><span class=\"line\">into outfile &apos;C:\\\\TEMP||emp_list.txt&apos; </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<p>默认列间用制表符（’\\t’）隔开，记录间用换行符（’\\n’）隔开。</p>\n<ul>\n<li>改成用字符 ‘|’隔开<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, start_date </span><br><span class=\"line\">into outfile &apos;C:\\\\TEMP||emp_list.txt&apos; </span><br><span class=\"line\">fields terminated by &apos;|&apos; </span><br><span class=\"line\">lines terminated by &apos;@&apos; </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"组合insert-update语句\"><a href=\"#组合insert-update语句\" class=\"headerlink\" title=\"组合insert/update语句\"></a>组合insert/update语句</h5><p>更新插入（upsert）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into branch_usage (branch_id, cust_id, last_visited_on) </span><br><span class=\"line\">values (1,5, current_timestamp()) </span><br><span class=\"line\">on duplicate key update last_visited_on = current_timestamp();</span><br></pre></td></tr></table></figure>\n<h5 id=\"多表更新与删除\"><a href=\"#多表更新与删除\" class=\"headerlink\" title=\"多表更新与删除\"></a>多表更新与删除</h5><p>同时删除account、customer、individual表中的某一个客户数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete account2, customer2, individual2 </span><br><span class=\"line\">from account2 inner join customer2 </span><br><span class=\"line\">on account2.cust_id=customer2.cust_id </span><br><span class=\"line\">inner join individual2 </span><br><span class=\"line\">on customer2.cust_id = individual2.cust_id </span><br><span class=\"line\">where individual2.cust_id = 1;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"创建和使用数据库\"><a href=\"#创建和使用数据库\" class=\"headerlink\" title=\"创建和使用数据库\"></a>创建和使用数据库</h3><ul>\n<li><p>主键约束<br><code>constraint pk_person primary key (person_id)</code></p>\n</li>\n<li><p>检查约束<br><code>gender char(1) check (gender in (&#39;M&#39;,&#39;F&#39;)),</code></p>\n</li>\n</ul>\n<p>或用<code>gender ENUM(&#39;M&#39;,&#39;F&#39;),</code>代替检查约束</p>","more":"<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> person</span><br><span class=\"line\">(person_id <span class=\"built_in\">smallint</span> <span class=\"keyword\">unsigned</span>,</span><br><span class=\"line\">fname <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">lname <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">gender enum(<span class=\"string\">'M'</span>,<span class=\"string\">'F'</span>),</span><br><span class=\"line\">birth_date <span class=\"built_in\">date</span>,</span><br><span class=\"line\">street <span class=\"built_in\">varchar</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">city <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">state <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">country <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">postal_code <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> pk_person primary <span class=\"keyword\">key</span> (person_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> favorite_food</span><br><span class=\"line\">(person_id <span class=\"built_in\">smallint</span> <span class=\"keyword\">unsigned</span>,</span><br><span class=\"line\">food <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> pk_favorite_food primary <span class=\"keyword\">key</span> (person_id, food),</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> fk_fav_food_person_id <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> (person_id)</span><br><span class=\"line\"><span class=\"keyword\">references</span> person (person_id)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><strong>此时想要给person表主键增加auto_incremnt</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table person modify person_id smallint unsigned auto_increment;</span><br></pre></td></tr></table></figure></p>\n<p>报错，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error Code: 1833. Cannot change column &apos;person_id&apos;: used in a foreign key constraint &apos;fk_fav_food_person_id&apos; of table &apos;table.favorite_food&apos;</span><br></pre></td></tr></table></figure></p>\n<p>，因为被用在favorite_food表中作为外键了，不允许修改，</p>\n<p>==Solution 1==：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock tables </span><br><span class=\"line\">favorite_food write,</span><br><span class=\"line\">person write;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table favorite_food </span><br><span class=\"line\">drop foreign key fk_fav_food_person_id,</span><br><span class=\"line\">modify person_id smallint unsigned;</span><br></pre></td></tr></table></figure>\n<p>然后再修改person主键<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table person modify person_id smallint unsigned auto_increment;</span><br></pre></td></tr></table></figure></p>\n<p>创建外键<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table favorite_food </span><br><span class=\"line\">add constraint fk_fav_food_person_id foreign key (person_id) </span><br><span class=\"line\">references person (person_id);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unlock tables;</span><br></pre></td></tr></table></figure>\n<p>==solution 2==</p>\n<p>You can turn off foreign key checks:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">/* DO WHAT YOU NEED HERE */</span><br><span class=\"line\"></span><br><span class=\"line\">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure>\n<p>插入一条数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into person </span><br><span class=\"line\">(person_id, fname, lname,gender,birth_date) </span><br><span class=\"line\">values (null, &apos;William&apos;, &apos;Turner&apos;,&apos;M&apos;,&apos;1972-05-27&apos;);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into favorite_food (person_id,food) </span><br><span class=\"line\">values (1, &apos;pizza&apos;);</span><br><span class=\"line\">insert into favorite_food (person_id,food) </span><br><span class=\"line\">values (1, &apos;cookies&apos;);</span><br><span class=\"line\">insert into favorite_food (person_id,food) </span><br><span class=\"line\">values (1, &apos;nachos&apos;);</span><br></pre></td></tr></table></figure>\n<p>更新数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update person </span><br><span class=\"line\">set street=&apos;1225 Tremont St.&apos;,</span><br><span class=\"line\">city=&apos;Boston&apos;,</span><br><span class=\"line\">state=&apos;MA&apos;,</span><br><span class=\"line\">country=&apos;USA&apos;,</span><br><span class=\"line\">postal_code=&apos;02138&apos; </span><br><span class=\"line\">where person_id=1;</span><br></pre></td></tr></table></figure></p>\n<p>删除数据<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from person </span><br><span class=\"line\">where person_id=2;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">&apos;ACTIVE&apos;,</span><br><span class=\"line\">emp_id * 3.14159,</span><br><span class=\"line\">UPPER(lname) </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<p>执行内建函数或对简单的表达式求值可以完全省略from子句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select version(),</span><br><span class=\"line\">user(),</span><br><span class=\"line\">database();</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列的别名：\"><a href=\"#列的别名：\" class=\"headerlink\" title=\"列的别名：\"></a>列的别名：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,</span><br><span class=\"line\">&apos;ACTIVE&apos; status,</span><br><span class=\"line\">emp_id * 3.14159 empid_x_pi,</span><br><span class=\"line\">UPPER(lname) last_name_upper </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<p>(可以在别名前加上AS关键字)</p>\n<h4 id=\"去除重复的行\"><a href=\"#去除重复的行\" class=\"headerlink\" title=\"去除重复的行\"></a>去除重复的行</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct cust_id </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure>\n<p>==注：产生无重复的结果集需要首先对数据排序，因此，不要为了确保去重二使用DiSTINCT，而应先了解所使用的数据是否可能包含重复的行。==</p>\n<h4 id=\"from子句\"><a href=\"#from子句\" class=\"headerlink\" title=\"from子句\"></a>from子句</h4><p>from子句定义了查询中所使用的表，以及连接这些表的方式。</p>\n<ul>\n<li>表<ul>\n<li>永久表（create table语句创建的表）</li>\n<li>临时表（子查询返回的表）</li>\n<li>虚拟表（create view）</li>\n</ul>\n</li>\n</ul>\n<p>通过别名e来引用子查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.emp_id, e.fname, e.lname </span><br><span class=\"line\">from (select emp_id,fname,lname,start_date,title </span><br><span class=\"line\">from employee) e;</span><br></pre></td></tr></table></figure></p>\n<p>视图是存储在数据字典中的查询，它的行为表现的像一个表，但实际上并不拥有任何数据（因此称为虚拟表）。当发出一个对视图的查询时，该查询会被绑定到视图定义上，以产生最终被执行的查询。</p>\n<ol>\n<li>定义一个查询employee表的视图</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view employee_vw AS </span><br><span class=\"line\">select emp_id, fname, lname, </span><br><span class=\"line\">YEAE(start_date) start_year </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>查询视图</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, start_year </span><br><span class=\"line\">from employee_vw;</span><br></pre></td></tr></table></figure>\n<h5 id=\"表连接\"><a href=\"#表连接\" class=\"headerlink\" title=\"表连接\"></a>表连接</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select employee.emp_id,employee.fname,employee.lname,</span><br><span class=\"line\">department.name dept_name </span><br><span class=\"line\">from employee inner join department </span><br><span class=\"line\">on employee.dept_id=department.dept_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"定义表别名\"><a href=\"#定义表别名\" class=\"headerlink\" title=\"定义表别名\"></a>定义表别名</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.emp_id,e.fname,e.lname,</span><br><span class=\"line\">d.name dept_name </span><br><span class=\"line\">from employee e inner join department d </span><br><span class=\"line\">on e.dept_id=d.dept_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"where子句\"><a href=\"#where子句\" class=\"headerlink\" title=\"where子句\"></a>where子句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date,title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where title=&apos;Head Teller&apos; </span><br><span class=\"line\">AND start_date &gt; &apos;2006-01-01&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"group-by和having子句\"><a href=\"#group-by和having子句\" class=\"headerlink\" title=\"group by和having子句\"></a>group by和having子句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select d.name,count(e.emp_id) num_employees </span><br><span class=\"line\">from department d inner join employee e </span><br><span class=\"line\">on d.dept_id=e.dept_id </span><br><span class=\"line\">group by d.name </span><br><span class=\"line\">having count(e.emp_id) &gt; 2;</span><br></pre></td></tr></table></figure>\n<h4 id=\"order-by\"><a href=\"#order-by\" class=\"headerlink\" title=\"order by\"></a>order by</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, product_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">order by open_emp_id;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>升序（ASC、默认）</li>\n<li>降序DESC</li>\n</ul>\n<h5 id=\"根据表达式排序\"><a href=\"#根据表达式排序\" class=\"headerlink\" title=\"根据表达式排序\"></a>根据表达式排序</h5><p>使用right()内建函数提取fed_id列的最后三个字符排序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,cust_type_cd,city,state,fed_id </span><br><span class=\"line\">from customer </span><br><span class=\"line\">order by right(fed_id, 3);</span><br></pre></td></tr></table></figure>\n<h5 id=\"根据数字占位符排序\"><a href=\"#根据数字占位符排序\" class=\"headerlink\" title=\"根据数字占位符排序\"></a>根据数字占位符排序</h5><p>根据查询返回的第2，5列排序：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,title,start_date,fname.lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">order by 2,5;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h3><h4 id=\"条件类型\"><a href=\"#条件类型\" class=\"headerlink\" title=\"条件类型\"></a>条件类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select pt.name product_type,p.name product </span><br><span class=\"line\">from product p inner join product_type pt </span><br><span class=\"line\">on p.product_type_cd = pt.product_type_cd </span><br><span class=\"line\">where pt.name = &apos;Customer Accounts&apos;;</span><br></pre></td></tr></table></figure>\n<p>不等条件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select pt.name product_type,p.name product </span><br><span class=\"line\">from product p inner join product_type pt </span><br><span class=\"line\">on p.product_type_cd = pt.product_type_cd </span><br><span class=\"line\">where pt.name &lt;&gt; &apos;Customer Accounts&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>描述不等条件时，可以用<code>&lt;&gt;</code>也可以用<code>!=</code></p>\n<h5 id=\"范围条件\"><a href=\"#范围条件\" class=\"headerlink\" title=\"范围条件\"></a>范围条件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where start_date&lt;&apos;2007-01-01&apos;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where start_date &lt;&apos;2007-01-01&apos; </span><br><span class=\"line\">and start_date &gt;= &apos;2005-01-01&apos;;</span><br></pre></td></tr></table></figure>\n<p>between(两端都是包含)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,start_date </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where start_date between &apos;2005-01-01&apos; and &apos;2006-12-31&apos;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,fed_id </span><br><span class=\"line\">from customer </span><br><span class=\"line\">where cust_type_cd=&apos;I&apos;</span><br><span class=\"line\">and fed_id between &apos;500-00-0000&apos; and &apos;999-99-9999&apos;;</span><br></pre></td></tr></table></figure>\n<p>in操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_id,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd in (&apos;CHK&apos;,&apos;SAV&apos;,&apos;CD,&apos;MM&apos;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_id,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd in (select product_cd from product </span><br><span class=\"line\">where product_type_cd = &apos;ACCOUNT&apos;);</span><br></pre></td></tr></table></figure>\n<p>not in<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_cd,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd not in (&apos;CHK&apos;,&apos;SAV&apos;,&apos;CD&apos;,&apos;MM&apos;);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"匹配条件\"><a href=\"#匹配条件\" class=\"headerlink\" title=\"匹配条件\"></a>匹配条件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where left(lname,1)=&apos;T&apos;;</span><br></pre></td></tr></table></figure>\n<p>可以使用内建函数left()，但更好的做法是使用通配符：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where lname like &apos;_a%e%&apos;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,fed_id </span><br><span class=\"line\">from customer </span><br><span class=\"line\">where fed_id like &apos;___-__-____&apos;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname </span><br><span class=\"line\">from employee</span><br><span class=\"line\">where lname like &apos;F%&apos; or lname like &apos;G%&apos;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where lname regexp &apos;^[FG]&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id,fname,lname,superior_emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where superior_emp_id is NULL;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h3><h5 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h5><p>交叉连接</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname,d.name </span><br><span class=\"line\">from employee e join department d;</span><br></pre></td></tr></table></figure>\n<h5 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h5><p>如果在一个表中的dept_id列中存在某个值，但该值在另一张表的dept_id列中不存在，那么相关行的连接会失败，在结果集中将会排除包含该值的行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname,d.name </span><br><span class=\"line\">from employee e join department d </span><br><span class=\"line\">on e.dept_id = d.dept_id;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上面没加inner关键字，默认使用inner，但最好加上。</li>\n<li>如果连接两个表的列名是相同的，可以使用using子句代替on子句：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname,d.name </span><br><span class=\"line\">from employee e inner join department d </span><br><span class=\"line\">using (dept_id);</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接3个或更多的表\"><a href=\"#连接3个或更多的表\" class=\"headerlink\" title=\"连接3个或更多的表\"></a>连接3个或更多的表</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id,c.fed_id,e.fname,e.lname </span><br><span class=\"line\">from account a inner join customer c </span><br><span class=\"line\">on a.cust_id=c.cust_id </span><br><span class=\"line\">inner join employee e </span><br><span class=\"line\">on a.open_emp_id = e.emp_id </span><br><span class=\"line\">where c.cust_type_cd = &apos;B&apos;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"将子查询结果作为查询表\"><a href=\"#将子查询结果作为查询表\" class=\"headerlink\" title=\"将子查询结果作为查询表\"></a>将子查询结果作为查询表</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id,a.cust_id,a.open_date,a.product_cd </span><br><span class=\"line\">from account a INNER JOIN </span><br><span class=\"line\">    (select emp_id,assigned_branch_id </span><br><span class=\"line\">    from employee </span><br><span class=\"line\">    where start_date &lt; &apos;2007-01-01&apos; </span><br><span class=\"line\">    and (title = &apos;Teller&apos; OR title = &apos;Head Teller&apos;)) e</span><br><span class=\"line\">    ON a.open_emp_id = e.emp_id </span><br><span class=\"line\">    INNER JOIN</span><br><span class=\"line\">        (select branch_id </span><br><span class=\"line\">        from branch </span><br><span class=\"line\">        where name = &apos;Woburn Branch&apos;) b </span><br><span class=\"line\">        ON e.assigned_branch_id = b.branch_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"连续两次使用同一个表\"><a href=\"#连续两次使用同一个表\" class=\"headerlink\" title=\"连续两次使用同一个表\"></a>连续两次使用同一个表</h5><p>需要给每个branch表的实例定义不用的别名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id,e.emp_id,</span><br><span class=\"line\">b_a.name open_branch,b_e.name emp_branch </span><br><span class=\"line\">from account a inner join branch b_a </span><br><span class=\"line\">on a.open_branch_id=b_a.branch_id </span><br><span class=\"line\">inner join employee e </span><br><span class=\"line\">on a.open_emp_id=e.emp_id </span><br><span class=\"line\">inner join branch b_e </span><br><span class=\"line\">on e.assigned_branch_id=b_e.branch_id </span><br><span class=\"line\">where a.product_cd=&apos;CHK&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"自连接\"><a href=\"#自连接\" class=\"headerlink\" title=\"自连接\"></a>自连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname,e.lname </span><br><span class=\"line\">e_mgr.fname mgr_fname,e_mgr.lname mgr_lname </span><br><span class=\"line\">from employee e inner join employee e_mgr </span><br><span class=\"line\">on e.superior_emp_id = e_mgr.emp_id;</span><br></pre></td></tr></table></figure>\n<p>上面语句列出了雇员姓名和主管姓名，但是employee表中一共有18行，但此查询只返回17行，这是由于银行的总经理并没有自己的主管（superior_emp_id列为null），因此在该行连接失败了。为了在结果集中包含这个数据，应使用外连接。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e1.fname, e1.lname, &apos;VS&apos; vs, e2.fname, e2.lname </span><br><span class=\"line\">from employee e1 inner join employee e2 </span><br><span class=\"line\">on e1.emp_id &lt; e2.emp_id </span><br><span class=\"line\">where e1.title=&apos;Teller&apos; and e2.title = &apos;Teller&apos;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接条件和过滤条件\"><a href=\"#连接条件和过滤条件\" class=\"headerlink\" title=\"连接条件和过滤条件\"></a>连接条件和过滤条件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, c.fed_id </span><br><span class=\"line\">from account a inner join customer c </span><br><span class=\"line\">on a.cust_id = c.cust_id </span><br><span class=\"line\">where c.cust_type_cd = &apos;B&apos;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用集合\"><a href=\"#使用集合\" class=\"headerlink\" title=\"使用集合\"></a>使用集合</h3><ul>\n<li>当对两个数据集合执行集合操作时，必须满足：<ul>\n<li>两个数据集合必须具有同样数目的列</li>\n<li>两个数据集中对应列的数据类型必须是一样的（或者服务器能偶从一种转换成另一种）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select 1 num, &apos;abc&apos; str </span><br><span class=\"line\">union </span><br><span class=\"line\">select 9 num, &apos;xyz&apos; str;</span><br></pre></td></tr></table></figure>\n<h5 id=\"union操作符\"><a href=\"#union操作符\" class=\"headerlink\" title=\"union操作符\"></a>union操作符</h5><p>union对连接后的集合排序并去除重复项，而union all保留重复项。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;IND&apos; type_cd, cust_id, lname name </span><br><span class=\"line\">from individual </span><br><span class=\"line\">union all </span><br><span class=\"line\">select &apos;BUS&apos; type_cd, cust_id, name </span><br><span class=\"line\">from business;</span><br></pre></td></tr></table></figure>\n<p>返回重复数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where assigned_branch_id=2 </span><br><span class=\"line\">and (title=&apos;Teller&apos; or title=&apos;Head Teller&apos;) </span><br><span class=\"line\">union all </span><br><span class=\"line\">select distinct open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = 2;</span><br></pre></td></tr></table></figure>\n<p>查询结果含有重复项，如果要排除重复项，需要把union all改成union</p>\n<h5 id=\"intersect-操作符\"><a href=\"#intersect-操作符\" class=\"headerlink\" title=\"intersect 操作符\"></a>intersect 操作符</h5><p>intersect 查找交集，并且去除了交集区域中所有重复的行，不删除重复的的是intersect all操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where assigned_branch_id=2 </span><br><span class=\"line\">and (title=&apos;Teller&apos; or title=&apos;Head Teller&apos;) </span><br><span class=\"line\">intersect  </span><br><span class=\"line\">select distinct open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = 2;</span><br></pre></td></tr></table></figure>\n<h5 id=\"except操作符\"><a href=\"#except操作符\" class=\"headerlink\" title=\"except操作符\"></a>except操作符</h5><p>except操作符返回第一个表减去第二个表重合的元素后剩下的部分。<br>except在集合A中去除所有的重复数据，而except all则根据重复数据在集合B中出现的次数进行删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where assigned_branch_id=2 </span><br><span class=\"line\">and (title=&apos;Teller&apos; or title=&apos;Head Teller&apos;) </span><br><span class=\"line\">except   </span><br><span class=\"line\">select distinct open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = 2;</span><br></pre></td></tr></table></figure>\n<h5 id=\"集合操作符优先级\"><a href=\"#集合操作符优先级\" class=\"headerlink\" title=\"集合操作符优先级\"></a>集合操作符优先级</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd in (&apos;SAV&apos;,&apos;MM&apos;) </span><br><span class=\"line\">union all </span><br><span class=\"line\">select a.cust_id </span><br><span class=\"line\">from account a inner join branch b </span><br><span class=\"line\">on a.open_branch_id = b.branch_id </span><br><span class=\"line\">where b.name = &apos;Woburn Branch&apos; </span><br><span class=\"line\">union </span><br><span class=\"line\">select cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where avail_balance between 500 and 2500;</span><br></pre></td></tr></table></figure>\n<p>复合查询包含3个或3个以上的查询语句，他们是自顶向下的顺序解析和执行的，但要注意：</p>\n<ul>\n<li>在调用集合操作时，intersect操作符比其他操作符具有更高的优先级</li>\n<li>可以用圆括号对多个查询进行封装，以明确指定他们的指定次序</li>\n</ul>\n<p>MySQL 没有实现intersect操作符</p>\n<h3 id=\"数据生成、转换和操作\"><a href=\"#数据生成、转换和操作\" class=\"headerlink\" title=\"数据生成、转换和操作\"></a>数据生成、转换和操作</h3><h4 id=\"使用字符串数据\"><a href=\"#使用字符串数据\" class=\"headerlink\" title=\"使用字符串数据\"></a>使用字符串数据</h4><ul>\n<li><code>CHAR</code><ul>\n<li>固定长度，不足部分使用空格填充的字符串</li>\n<li>MySQL的CHAR类型的长度为255字节。</li>\n<li>Oracle为2000</li>\n<li>SQL Server 8000</li>\n</ul>\n</li>\n<li><code>varchar</code><ul>\n<li>变长字符串。</li>\n<li>MySQL允许的varchar列最多包含65536个字符</li>\n<li>Oracle为4000</li>\n<li>SQL Server为8000</li>\n</ul>\n</li>\n<li><code>text</code>(MySQL和SQL Server) 或 <code>CLOB</code>(Character Large Object; Oracle)<ul>\n<li>MySQL有多种text类型，最多4GB</li>\n<li>SQL只有text，最长2GB</li>\n<li>Oracle的CLOB，最大128TB</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table string_tbl</span><br><span class=\"line\">(char_fld CHAR(30),</span><br><span class=\"line\">vchar_fld varchar(30),</span><br><span class=\"line\">text_fld text);</span><br></pre></td></tr></table></figure>\n<h5 id=\"生成字符串\"><a href=\"#生成字符串\" class=\"headerlink\" title=\"生成字符串\"></a>生成字符串</h5><p>MySQL 6.0中，默认行为是“strict”模式，发生问题时抛出异常，而在早先的服务器版本中，默认方式是截断字符串并发出一个警告。如果希望数据库引擎采取后一种方式，可以将之修改为ANSI模式。</p>\n<ul>\n<li>查看数据库当前模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select @@session.sql_mode;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>改变当前模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set sql_mode=&apos;ansi&apos;;</span><br></pre></td></tr></table></figure>\n<p>==由于服务器是在纯粹字符串时按需分配空间，因此不会因为将varchar列的上限值设的比较大而浪费资源。==</p>\n<ul>\n<li>单引号转义符</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update string_tb1 set text_fld=&apos;This string didn&apos;&apos;t work, but it does now&apos;;</span><br></pre></td></tr></table></figure>\n<p>可以使用单引号作为转义符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update string_tb1 set text_fld=&apos;This string didn\\&apos;t work, but it does now&apos;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>使用内建函数quote()，他用单引号将整个字符串包含起来，并为字符串本身的单引号/撇号增加转义符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select quote(text_fld) </span><br><span class=\"line\">from string_tbl;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>包含特殊字符 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;abcdefg&apos;, CHAR(97,98,99,100,101,102,103);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select CHAR(138,139,140,141,142,143,144,145,146,147);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select concat(&apos;danke sch&apos;, char(148), &apos;n&apos;);</span><br></pre></td></tr></table></figure>\n<p>字符串长度：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select length(char_fld) char_length,</span><br><span class=\"line\">length(vchar_fld) varchar_length,</span><br><span class=\"line\">length(text_fld) text_length </span><br><span class=\"line\">from string_tbl;</span><br></pre></td></tr></table></figure></p>\n<p>字符串位置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select position(&apos;characters&apos; in vchar_fld) </span><br><span class=\"line\">from string_tbl;</span><br></pre></td></tr></table></figure></p>\n<p>如果找不到该子字符串，那么position()函数将返回0.</p>\n<p>从任意位置开始查找字符串位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select locate(&apos;is&apos;, vchar_fld, 5) </span><br><span class=\"line\">froom string_tbl;</span><br></pre></td></tr></table></figure>\n<p>字符串比较（只有mysql）</p>\n<p>mysql的strcmp()大小写不敏感</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select strcmp(&apos;12345&apos;, &apos;abc&apos;) 12345_abc,</span><br><span class=\"line\">strcmp(&apos;abcd&apos;, &apos;xyz&apos;) abcd_xyz,</span><br><span class=\"line\">strcmp(&apos;qrstuv&apos;, &apos;QRSTUV&apos;) qrstuv_QRSTUV;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>like<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,name like &apos;%ns&apos; ends_in_ns </span><br><span class=\"line\">from department;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id, cust_type_cd, fed_id, </span><br><span class=\"line\">fed_id regexp &apos;_&#123;3&#125;-_&#123;2&#125;-_&#123;4&#125;&apos; is_ss_no_format </span><br><span class=\"line\">from customer;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>concat()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update string_tbl </span><br><span class=\"line\">set text_fld = concat(text_fld, &apos;, but now it is longer&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Oracle下，可以使用连接操作符<code>||</code>代替concat()进行字符串连接<br>SQL Server并么有concat()函数，使用的是连接操作符<code>+</code></p>\n<ul>\n<li>插入字符串 insert()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select insert(&apos;goodbye world&apos;, 9, 0, &apos;cruel &apos;) string;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如果第三个参数大于0，那么相应数目的字符将会被替换字符串所取代：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select insert(&apos;goodbye world&apos;, 1, 7, &apos;hello&apos;) string;</span><br></pre></td></tr></table></figure>\n<p>Oracle数据没有提供MySQL中的insert()类似函数，但他的replace()函数也可以用于替换字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select replace(&apos;goodbye world&apos;, &apos;goodbye&apos;, &apos;hello&apos;) from dual;</span><br></pre></td></tr></table></figure>\n<p>SQL Server 同样包含replace()函数，除此之外，还包含stuff()函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select stuff(&apos;hello world&apos;, 1, 5, &apos;goodbye cruel&apos;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>子串 substring()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select substring(&apos;goodbye cruel world&apos;, 9, 5);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"使用数值数据\"><a href=\"#使用数值数据\" class=\"headerlink\" title=\"使用数值数据\"></a>使用数值数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select (37 * 59) / (78 - (8 * 6));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select mod(10,4);</span><br><span class=\"line\"></span><br><span class=\"line\">select pow(2, 8);</span><br></pre></td></tr></table></figure>\n<h5 id=\"控制数字经度\"><a href=\"#控制数字经度\" class=\"headerlink\" title=\"控制数字经度\"></a>控制数字经度</h5><ul>\n<li>ceil()</li>\n<li>floor()</li>\n<li>round() 四舍五入，保留n位小数</li>\n<li>truncate() 直接舍掉后面的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select ceil(72.445),floor(72.445);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>结果:<code>73    72</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select round(72.4999),round(72.5);</span><br><span class=\"line\"></span><br><span class=\"line\">select round(72.0909, 1), round(72.0909,2), round(72.0909, 3);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select truncate(72.0909,1), truncate(72.0909,2), truncate(72.0909,3);</span><br></pre></td></tr></table></figure>\n<p>truncate()和round()第二个参数都可以指定为负数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select round(17, -1), truncate(17, -1);</span><br></pre></td></tr></table></figure></p>\n<p>结果：<br><code>20  10</code></p>\n<h5 id=\"处理有符号数\"><a href=\"#处理有符号数\" class=\"headerlink\" title=\"处理有符号数\"></a>处理有符号数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, sign(avail_balance), abs(avail_balance) </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>sign()函数取符号</li>\n<li>abs()函数取绝对值</li>\n</ul>\n<h4 id=\"使用时间数据\"><a href=\"#使用时间数据\" class=\"headerlink\" title=\"使用时间数据\"></a>使用时间数据</h4><ul>\n<li>时区设置：全局时区和会话时区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select @@global.time_zone,@@session.time_zone;</span><br></pre></td></tr></table></figure>\n<p>服务器自动将字符串适配到datetime列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update transaction </span><br><span class=\"line\">set txn_date = &apos;2008-09-17 15:30:00&apos; </span><br><span class=\"line\">where txn_id = 99999;</span><br></pre></td></tr></table></figure></p>\n<p>使用cast()函数转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cast(&apos;2008-09-17 15:30:00&apos; as datetime);</span><br><span class=\"line\"></span><br><span class=\"line\">select cast(&apos;2009-09-17&apos; as date) date_field </span><br><span class=\"line\">select cast(&apos;108:17:57&apos; as time) time_field;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><code>str_to_date()</code>函数  将字符串格式化为日期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update individual </span><br><span class=\"line\">set birth_date = str_to_date(&apos;September 17, 2008&apos;, &apos;%M %d, %Y&apos;) </span><br><span class=\"line\">where cust_id = 9999;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当前日期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select current_date(), current_time(), current_timestamp();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当前日期加上5天 <code>date_add()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select date_add(current_date(), interval 5 day);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update transaction </span><br><span class=\"line\">set txn_date = date_add(txn_date, interval &apos;3:27:11&apos; hour_second) </span><br><span class=\"line\">where txn_id = 9999;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>当月最后一天  <code>last_day()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select last_day(&apos;2008-09-17&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>返回某一天是星期几 <code>dayname()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dayname(&apos;2008-09-18&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提取日期值中的信息 <code>extract()</code>函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select extract(year from &apos;2008-09-18 22:19:05&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>时间间隔 <code>datediff()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select datediff(&apos;2009-09-03&apos;, &apos;2009-06-24&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"转换函数\"><a href=\"#转换函数\" class=\"headerlink\" title=\"转换函数\"></a>转换函数</h4><ul>\n<li><code>cast()</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cast(&apos;14567&apos; as signed integer);</span><br></pre></td></tr></table></figure>\n<p>遇到非数字的字符，转换将中止并不返回错误：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selct cast(&apos;999ABC111&apos; as unsigned integer);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"分组与聚集\"><a href=\"#分组与聚集\" class=\"headerlink\" title=\"分组与聚集\"></a>分组与聚集</h3><ul>\n<li><p>group by</p>\n</li>\n<li><p>分组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>分组，并查看每一个分组的数量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>过滤出条数大于4的分组，需要用having，不能用where，因为用where过滤的时候，还未分组</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">having count(*) &gt; 4;</span><br></pre></td></tr></table></figure>\n<h4 id=\"聚集函数\"><a href=\"#聚集函数\" class=\"headerlink\" title=\"聚集函数\"></a>聚集函数</h4><ul>\n<li>Max()</li>\n<li>Min()</li>\n<li>Avg()</li>\n<li>Sum()</li>\n<li>Count()</li>\n</ul>\n<h5 id=\"隐式或显式分组\"><a href=\"#隐式或显式分组\" class=\"headerlink\" title=\"隐式或显式分组\"></a>隐式或显式分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select max(avail_balance) max_balance,</span><br><span class=\"line\">min(avail_balance) min_balance,</span><br><span class=\"line\">avg(avail_balance) avg_balance,</span><br><span class=\"line\">sum(avail_balance) sum_balance,</span><br><span class=\"line\">count(*) num_accounts </span><br><span class=\"line\">from account </span><br><span class=\"line\">where product_cd = &apos;CHK&apos;;</span><br></pre></td></tr></table></figure>\n<p>上个例子中，查询返回的每个值都是由聚集函数产生的，这些聚集函数作用于使用过滤条件product_cd=’CHK’指定的分组上的所有行。这里没有使用group by子句，因此它是一个隐式分组（即包含查询返回的所有行）。</p>\n<p>但如果同时需要提取product_cd列，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd,</span><br><span class=\"line\">max(avail_balance) max_balance,</span><br><span class=\"line\">min(avail_balance) min_balance,</span><br><span class=\"line\">avg(avail_balance) avg_balance,</span><br><span class=\"line\">sum(avail_balance) sum_balance,</span><br><span class=\"line\">count(*) num_accounts </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure></p>\n<p>将会报错，因为没有显式地指定如何对数据分组。改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd,</span><br><span class=\"line\">max(avail_balance) max_balance,</span><br><span class=\"line\">min(avail_balance) min_balance,</span><br><span class=\"line\">avg(avail_balance) avg_balance,</span><br><span class=\"line\">sum(avail_balance) sum_balance,</span><br><span class=\"line\">count(*) num_accounts </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"对独立值计数\"><a href=\"#对独立值计数\" class=\"headerlink\" title=\"对独立值计数\"></a>对独立值计数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(open_emp_id)</span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure>\n<p>去除重复的行统计：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(distinct open_emp_id) </span><br><span class=\"line\">from account;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"对null的计算\"><a href=\"#对null的计算\" class=\"headerlink\" title=\"对null的计算\"></a>对null的计算</h5><p>count(*) 计算所有行<br>count(val) 会忽略null</p>\n<h4 id=\"产生分组\"><a href=\"#产生分组\" class=\"headerlink\" title=\"产生分组\"></a>产生分组</h4><h5 id=\"单列分组\"><a href=\"#单列分组\" class=\"headerlink\" title=\"单列分组\"></a>单列分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd, sum(avail_balance) prod_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd;</span><br></pre></td></tr></table></figure>\n<h5 id=\"对多列的分组\"><a href=\"#对多列的分组\" class=\"headerlink\" title=\"对多列的分组\"></a>对多列的分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd,open_branch_id, </span><br><span class=\"line\">sum(avail_balance) tot_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd, open_branch_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"利用表达式分组\"><a href=\"#利用表达式分组\" class=\"headerlink\" title=\"利用表达式分组\"></a>利用表达式分组</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select extract(year form start_date) year,</span><br><span class=\"line\">count(*) how_many </span><br><span class=\"line\">from employee </span><br><span class=\"line\">group by extract(year from start_date);</span><br></pre></td></tr></table></figure>\n<h5 id=\"产生合计数-with-rollup\"><a href=\"#产生合计数-with-rollup\" class=\"headerlink\" title=\"产生合计数 with rollup\"></a>产生合计数 with rollup</h5><ul>\n<li>独立产品也进行合计，最后还会产生总的合计</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd, open_branch_id,</span><br><span class=\"line\">sum(avail_balance) tot_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by product_cd, open_branch_id with rollup;</span><br></pre></td></tr></table></figure>\n<h4 id=\"分组过滤条件\"><a href=\"#分组过滤条件\" class=\"headerlink\" title=\"分组过滤条件\"></a>分组过滤条件</h4><ul>\n<li>分组前——用where过滤</li>\n<li>分组后——用having过滤</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select product_cd, sum(avail_balance) prod_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where status = &apos;ACTIVE&apos; </span><br><span class=\"line\">group by product_cd </span><br><span class=\"line\">having sum(avail_balance) &gt;=10000;</span><br></pre></td></tr></table></figure>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,product_id,cust_id,avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_emp_id &lt;&gt; (select e.emp_id </span><br><span class=\"line\">from employee e inner join branch b </span><br><span class=\"line\">on e.assigned_branch_id = b.branch_id </span><br><span class=\"line\">where e.title = &apos;Head Teller&apos; and b.city = &apos;Woburn&apos;);</span><br></pre></td></tr></table></figure>\n<p>上述子查询只有一个结果，否则会报错。</p>\n<h5 id=\"多行单列子查询\"><a href=\"#多行单列子查询\" class=\"headerlink\" title=\"多行单列子查询\"></a>多行单列子查询</h5><ul>\n<li>in 和 not in运算分<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select branch_id, name, city </span><br><span class=\"line\">from branch </span><br><span class=\"line\">where name in (&apos;Headquarters&apos;, &apos;Quincy Branch&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>查询所有主管：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where emp_id in (select superior_emp_id </span><br><span class=\"line\">from employee);</span><br></pre></td></tr></table></figure></p>\n<p>查询所有不管理别人的雇员：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where emp_id not in (select superior_emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where superior_emp_id is not null);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>all运算符<br>将某单值与集合中的每个值进行比较：</p>\n<p>查询非主管雇员：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, title </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where emp_id &lt;&gt; all (select superior_emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where superior_emp_id is not null);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==当使用not in或&lt;&gt;运算符比较一个值和一个值集时，必须确保值集中不包含null值，因为服务器将表达式左边的值与null比较时，都将产生未知的结果。==</p>\n<ul>\n<li>any运算符</li>\n</ul>\n<p>any运算符只要有一个比较成立，则条件为真。all需要都成立才为真。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id,cust_id,product_cd, avail_balance </span><br><span class=\"line\">from account </span><br><span class=\"line\">where avail_balance &gt; any (select a.avail_balance </span><br><span class=\"line\">from account a inner join individual i </span><br><span class=\"line\">on a.cust_id = i.cust_id </span><br><span class=\"line\">where i.fname = &apos;Frank&apos; and i.lname = &apos;Tucker&apos;);</span><br></pre></td></tr></table></figure>\n<h5 id=\"多列子查询\"><a href=\"#多列子查询\" class=\"headerlink\" title=\"多列子查询\"></a>多列子查询</h5><ul>\n<li>多重单列子查询：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, product_id, cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_branch_id = (select branch_id </span><br><span class=\"line\">from branch </span><br><span class=\"line\">where name = &apos;Woburn Branch&apos;) </span><br><span class=\"line\">and open_emp_id in (select emp_id </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where title = &apos;Teller&apos; or title = &apos;Head Teller&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>等同于下面的 多列子查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_id, product_id, cust_id </span><br><span class=\"line\">from account </span><br><span class=\"line\">where (open_branch_id, open_emp_id) in </span><br><span class=\"line\">(select b.branch_id, e.emp_id </span><br><span class=\"line\">from branch b inner join employee e </span><br><span class=\"line\">on b.branch_id = e.assigned_branch_id </span><br><span class=\"line\">where b.name = &apos;Woburn Branch&apos; </span><br><span class=\"line\">and (e.title = &apos;Teller&apos; or e.title = &apos;Head Teller&apos;));</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"关联子查询\"><a href=\"#关联子查询\" class=\"headerlink\" title=\"关联子查询\"></a>关联子查询</h4><p>子查询最后引用的c.cust_id使之具有关联性，这样他的执行必须依赖于包含查询提供的c.cust_id。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.cust_type_cd, c.city </span><br><span class=\"line\">from customer c </span><br><span class=\"line\">where 2 = (select count(*) </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where a.cust_id = c.cust_id);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.cust_type_cd, c.city</span><br><span class=\"line\">from customer c </span><br><span class=\"line\">where (select sum(a.avail_balance) </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where a.cust_id = c.cust_id)</span><br><span class=\"line\">between 5000 and 10000;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;ALTER! : Account #1 Hs Incorrect Balance!&apos; </span><br><span class=\"line\">from account </span><br><span class=\"line\">where (avail_balance, pending_balance) &lt;&gt; ¡™</span><br><span class=\"line\">(select sum(&lt;expression to generate available balance&gt;), </span><br><span class=\"line\">sum(&lt;expression to generate pending balance&gt;) </span><br><span class=\"line\">from transaction </span><br><span class=\"line\">where account_id = 1) </span><br><span class=\"line\">and account_id = 1;</span><br></pre></td></tr></table></figure>\n<p>对于上面的例子，用关联子查询代替非关联子查询，升级为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select &apos;ALTER! : Account #1 Hs Incorrect Balance!&apos; </span><br><span class=\"line\">from account t </span><br><span class=\"line\">where (avail_balance, pending_balance) &lt;&gt; </span><br><span class=\"line\">(select sum(&lt;expression to generate available balance&gt;), </span><br><span class=\"line\">sum(&lt;expression to generate pending balance&gt;) </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"exists-运算符\"><a href=\"#exists-运算符\" class=\"headerlink\" title=\"exists 运算符\"></a>exists 运算符</h5><p>exists运算符是构造包含关联子查询条件最常用的运算符。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, a.cust_id, a.avail_balance </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where exists (select 1 </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id </span><br><span class=\"line\">and t.txn_date = &apos;2008-09-22&apos;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>not exists</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, a.cust_id </span><br><span class=\"line\">from account a </span><br><span class=\"line\">where not exists (select 1 </span><br><span class=\"line\">from business b </span><br><span class=\"line\">where b.cust_id = a.cust_id);</span><br></pre></td></tr></table></figure>\n<h5 id=\"关联子查询操作数据\"><a href=\"#关联子查询操作数据\" class=\"headerlink\" title=\"关联子查询操作数据\"></a>关联子查询操作数据</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update account a </span><br><span class=\"line\">set a.last_activity_date = </span><br><span class=\"line\">(select max(t.txn_date) </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id);</span><br></pre></td></tr></table></figure>\n<p>但是上面的子查询语句没有检查每个账户是否发生过交易，否则有可能为null，因此修改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update account a </span><br><span class=\"line\">set a.last_activity_date = </span><br><span class=\"line\">(select max(t.txn_date) </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id) </span><br><span class=\"line\">where exists (select 1 </span><br><span class=\"line\">from transaction t </span><br><span class=\"line\">where t.account_id = a.account_id);</span><br></pre></td></tr></table></figure></p>\n<p>删除没有员工的部门：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete from department </span><br><span class=\"line\">where not exists (select 1 </span><br><span class=\"line\">from employee </span><br><span class=\"line\">where employee.dept_id = department.dept_id);</span><br></pre></td></tr></table></figure>\n<p>==注：在MySQL中delete语句使用关联子查询时，不能使用表别名。==</p>\n<p>查找开户数最多的雇员：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">having count(*) = (select max(emp_cnt.how_many) </span><br><span class=\"line\">from (select count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id) emp_cnt);</span><br></pre></td></tr></table></figure>\n<p>检索雇员数据，排序第一准则是老板姓氏，第二是雇员的姓氏：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp.emp_id, concat(emp.fname, &apos; &apos;, emp.lname) emp_name, </span><br><span class=\"line\">(select concat(boss.fname, &apos; &apos;, boss.lname) </span><br><span class=\"line\">from employee boss </span><br><span class=\"line\">where boss.emp_id = emp.superior_emp_id) boss_name </span><br><span class=\"line\">from employee emp </span><br><span class=\"line\">where emp.superior_emp_id is not null </span><br><span class=\"line\">order by (select boss.lname from employee boss </span><br><span class=\"line\">where boss.emp_id = emp.superior_emp_id), emp.lname;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"再谈连接\"><a href=\"#再谈连接\" class=\"headerlink\" title=\"再谈连接\"></a>再谈连接</h3><h4 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.cust_id, b.name </span><br><span class=\"line\">from account a left outer join business b </span><br><span class=\"line\">on a.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure>\n<h5 id=\"左外连接与右外连接\"><a href=\"#左外连接与右外连接\" class=\"headerlink\" title=\"左外连接与右外连接\"></a>左外连接与右外连接</h5><p>left指连接左边的表决定结果集的行数，而右边只负责提供与之匹配的列值：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id,b.name </span><br><span class=\"line\">from customer c left outer join business b </span><br><span class=\"line\">on c.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure></p>\n<p>如果是右链接：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id,b.name </span><br><span class=\"line\">from customer c right outer join busines b </span><br><span class=\"line\">where c.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"三路外连接\"><a href=\"#三路外连接\" class=\"headerlink\" title=\"三路外连接\"></a>三路外连接</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.account_id, a.product_cd, </span><br><span class=\"line\">concat(i.fname, &apos; &apos;, i.lname) person_name,</span><br><span class=\"line\">b.name business_name </span><br><span class=\"line\">from account a left outer join individual i </span><br><span class=\"line\">on a.cust_id = i.cust_id </span><br><span class=\"line\">left outer join business b </span><br><span class=\"line\">on a.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure>\n<p>如果mysql对于外连接到同一个表的其他表的树木有限制，那么可以这么重写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select account_ind.account_id, account_ind.product_cd,</span><br><span class=\"line\">account_ind.person_name,</span><br><span class=\"line\">b.name business_name </span><br><span class=\"line\">from </span><br><span class=\"line\">(select a.account_id, a.product_cd, a.cust_id, </span><br><span class=\"line\">concat(i.fname, &apos; &apos;, i.lname) person name </span><br><span class=\"line\">from account a left outer join individual i </span><br><span class=\"line\">on a.cust_id = i.cust_id) account_ind </span><br><span class=\"line\">left outer join business b </span><br><span class=\"line\">on account_ind.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"自外连接\"><a href=\"#自外连接\" class=\"headerlink\" title=\"自外连接\"></a>自外连接</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select e.fname, e.lname,</span><br><span class=\"line\">e_mgr.fname mgr_fname, e_mgr.lname mgr_lname </span><br><span class=\"line\">from employee e left outer join employee e_mgr </span><br><span class=\"line\">on e.superior_emp_id = e_mgr.emp_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"交叉连接\"><a href=\"#交叉连接\" class=\"headerlink\" title=\"交叉连接\"></a>交叉连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select pt.name, p.product_cd, p.name </span><br><span class=\"line\">from product p cross join product_type pt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成2008年全年日期<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select date_add(&apos;2008-01-01&apos;, interval (ones.num + tens.num + hundreds.num) day) dt  </span><br><span class=\"line\">from </span><br><span class=\"line\">(select 0 num union all </span><br><span class=\"line\">select 1 num union all </span><br><span class=\"line\">select 2 num union all </span><br><span class=\"line\">select 3 num union all </span><br><span class=\"line\">select 4 num union all </span><br><span class=\"line\">select 5 num union all </span><br><span class=\"line\">select 6 num union all </span><br><span class=\"line\">select 7 num union all </span><br><span class=\"line\">select 8 num union all </span><br><span class=\"line\">select 9 num) ones </span><br><span class=\"line\">cross join </span><br><span class=\"line\">(select 0 num union all </span><br><span class=\"line\">select 10 num union all </span><br><span class=\"line\">select 20 num union all </span><br><span class=\"line\">select 30 num union all </span><br><span class=\"line\">select 40 num union all </span><br><span class=\"line\">select 50 num union all </span><br><span class=\"line\">select 60 num union all </span><br><span class=\"line\">select 70 num union all </span><br><span class=\"line\">select 80 num union all </span><br><span class=\"line\">select 90 num) tens  </span><br><span class=\"line\">cross join </span><br><span class=\"line\">(select 0 num union all </span><br><span class=\"line\">select 100 num union all </span><br><span class=\"line\">select 200 num union all </span><br><span class=\"line\">select 300 num) hundreds </span><br><span class=\"line\">where date_add(&apos;2008-01-01&apos;, </span><br><span class=\"line\">interval(ones.num+tens.num+hundreds.num) day) &lt; &apos;2009-01-01&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>==order by 1表示根据第一列的值自然排序。==</p>\n<h4 id=\"自然连接\"><a href=\"#自然连接\" class=\"headerlink\" title=\"自然连接\"></a>自然连接</h4><p>要避免不要使用自然连接。</p>\n<h3 id=\"条件逻辑\"><a href=\"#条件逻辑\" class=\"headerlink\" title=\"条件逻辑\"></a>条件逻辑</h3><ul>\n<li>根据cust_type_cd字段判断决定使用indiv_name还是business_name列的值：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.fed_id,</span><br><span class=\"line\">case </span><br><span class=\"line\">when c.cust_type_cd = &apos;I&apos; </span><br><span class=\"line\">then concat(i.fname, &apos; &apos;, i.lname) </span><br><span class=\"line\">when c.cust_type_cd = &apos;B&apos; </span><br><span class=\"line\">then b.name </span><br><span class=\"line\">else &apos;Unknown&apos; </span><br><span class=\"line\">end name </span><br><span class=\"line\">from customer c left outer join individual i </span><br><span class=\"line\">on c.cust_id = i.cust_id </span><br><span class=\"line\">left outer join business b </span><br><span class=\"line\">on c.cust_id = b.cust_id;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"case表达式\"><a href=\"#case表达式\" class=\"headerlink\" title=\"case表达式\"></a>case表达式</h4><h5 id=\"查找型case表达式\"><a href=\"#查找型case表达式\" class=\"headerlink\" title=\"查找型case表达式\"></a>查找型case表达式</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CASE </span><br><span class=\"line\">    WHEN C1 THEN E1 </span><br><span class=\"line\">    WHEN C2 THEN E2 </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    WHEN CN THEN CN </span><br><span class=\"line\">    [ELSE ED] </span><br><span class=\"line\">END</span><br></pre></td></tr></table></figure>\n<p>上面的语句可以改为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.fed_id,</span><br><span class=\"line\">case</span><br><span class=\"line\">    when c.cust_type_cd = &apos;I&apos; then </span><br><span class=\"line\">    (select concat(i.fname, &apos; &apos;, i.lname) </span><br><span class=\"line\">    from individual i </span><br><span class=\"line\">    where i.cust_id = c.cust_id) </span><br><span class=\"line\">    when c.cust_type_cd = &apos;B&apos; then </span><br><span class=\"line\">    (select b.name </span><br><span class=\"line\">    from business b </span><br><span class=\"line\">    where b.cust_id = c.cust_id) </span><br><span class=\"line\">    else &apos;Unknown&apos; </span><br><span class=\"line\">    end name </span><br><span class=\"line\">from customer c;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"结果集变换\"><a href=\"#结果集变换\" class=\"headerlink\" title=\"结果集变换\"></a>结果集变换</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select year(open_date) year, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_date &gt; &apos;1999-12-31&apos; </span><br><span class=\"line\">and open_date &lt; &apos;2006-01-01&apos; </span><br><span class=\"line\">group by year(open_date);</span><br></pre></td></tr></table></figure>\n<p>结果是6行，如果想要变换成单行6列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select </span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2000 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2000,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2001 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2001,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2002 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2002,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2003 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2003,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2004 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2004,</span><br><span class=\"line\">    sum(case </span><br><span class=\"line\">            when extract(year from open_date) = 2005 then 1 </span><br><span class=\"line\">            else 0 </span><br><span class=\"line\">        end) year_2005</span><br><span class=\"line\">from account </span><br><span class=\"line\">where open_date &gt; &apos;1999-12-31&apos; and open_date &lt; &apos;2006-01-01&apos;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"存在性检查\"><a href=\"#存在性检查\" class=\"headerlink\" title=\"存在性检查\"></a>存在性检查</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select c.cust_id, c.fed_id, c.cust_type_cd,</span><br><span class=\"line\">    case </span><br><span class=\"line\">        when exists (select 1 from account a </span><br><span class=\"line\">        where a.cust_id = c.cust_id </span><br><span class=\"line\">        and a.product_cd = &apos;CHK&apos;) then &apos;Y&apos; </span><br><span class=\"line\">        else &apos;N&apos; </span><br><span class=\"line\">    end has_checking,</span><br><span class=\"line\">    case</span><br><span class=\"line\">        when exists (select 1 froom account a </span><br><span class=\"line\">        where a.cust_id = c.cust_id </span><br><span class=\"line\">        and a.product_cd = &apos;SAV&apos;) then &apos;Y&apos; </span><br><span class=\"line\">        else &apos;N&apos; </span><br><span class=\"line\">    end has_savings </span><br><span class=\"line\">from customer c;</span><br></pre></td></tr></table></figure>\n<h5 id=\"除零错误\"><a href=\"#除零错误\" class=\"headerlink\" title=\"除零错误\"></a>除零错误</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select a.cust_id, a.product_cd, a.avail_balance / </span><br><span class=\"line\"> case</span><br><span class=\"line\">  when prod_tots.tot_balance = 0 then 1 </span><br><span class=\"line\">  else prod_tots.tot_balance </span><br><span class=\"line\"> end percent_of_total </span><br><span class=\"line\">from account a inner join </span><br><span class=\"line\">(select a.product_cd, sum(a.avail_balance) tot_balance </span><br><span class=\"line\">from account a </span><br><span class=\"line\">group by a.product_cd) prod_tots </span><br><span class=\"line\">on a.product_cd = prod_tots.product_cd;</span><br></pre></td></tr></table></figure>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><h4 id=\"多用户数据库\"><a href=\"#多用户数据库\" class=\"headerlink\" title=\"多用户数据库\"></a>多用户数据库</h4><h5 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h5><p>两种锁……</p>\n<ul>\n<li>==写锁+读锁==</li>\n<li>写锁，读取不需要锁。服务器要保证从查询开始到结束读操作看到一个一致的数据视图，这个方法被称为==版本控制==。</li>\n</ul>\n<h5 id=\"锁的粒度\"><a href=\"#锁的粒度\" class=\"headerlink\" title=\"锁的粒度\"></a>锁的粒度</h5><ul>\n<li>表锁</li>\n<li>页锁（阻止多用户同时修改某表中同一页（一页通常是一段2～16KB的内存空间）的数据）</li>\n<li>行锁</li>\n</ul>\n<p><strong>显式启动事务</strong>：</p>\n<ul>\n<li><p>SQL Server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">begin transaction</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>MySQL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start transaction</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>关闭自动提交：</strong></p>\n<ul>\n<li>SQL Server</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set implicit_transactions on</span><br></pre></td></tr></table></figure>\n<ul>\n<li>MySQL<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set autocommit=0</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于SQL Server和MySQL，默认自动提交模式，直到显示启动一个事务。</p>\n<p>一旦离开了自动提交模式，所有的SQL命令都会发生在同一个事务的范围，并且必须显式地对事务进行提交或回滚。</p>\n<h5 id=\"结束事务\"><a href=\"#结束事务\" class=\"headerlink\" title=\"结束事务\"></a>结束事务</h5><ul>\n<li>commit</li>\n<li>rollback</li>\n</ul>\n<p>除了提交commit或rollback指令，结束事务还可以有其他情景触发：</p>\n<ul>\n<li>服务器宕机</li>\n<li>提交一个SQL模式语句，比如alter table，这将会引起当前事务提交和一个新事务启动</li>\n<li>提交另一个start transaction命令，将会引起前一个事务提交</li>\n<li>因为服务器监测到一个死锁，并确定当前事务是罪魁祸首，服务器将会结束当前事务。这种情况下，事务将会被回滚，同时释放错误消息（大多数情况喜爱，终止的事务可以重启，如果没有再次遇到另一个死锁情况他将会成功）</li>\n</ul>\n<h5 id=\"事务保存点\"><a href=\"#事务保存点\" class=\"headerlink\" title=\"事务保存点\"></a>事务保存点</h5><p>6.0版的MySQL包括以下存储引擎：</p>\n<ul>\n<li>MyISAM    表级锁定的非事务引擎</li>\n<li>MEMORY    内存表使用的非事务引擎</li>\n<li>BDB       页级锁定的事务引擎</li>\n<li>InnoDB    行级锁定的事务引擎</li>\n<li>Merge     使多个相同的MyISAM看起来像一个单表（也叫表分割）的专用引擎</li>\n<li>Maria     6.0.6版本中MyISAM的替代品，他添加了充分的恢复功能</li>\n<li>Falcon    6.0.4版本起引入的采用行级锁定的高性能事务引擎</li>\n<li>Archive   用于存储大量未检索数据的专用引擎，主要用来存档</li>\n</ul>\n<p>查看引擎：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show table status like &apos;transaction&apos; \\G</span><br></pre></td></tr></table></figure></p>\n<p>设置引擎：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table transaction engine = innodb;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>创建保存点</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">savepoint my_savepoint;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>回滚到保存点</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rollback to savepoint my_savepoint;</span><br></pre></td></tr></table></figure>\n<h3 id=\"索引和约束\"><a href=\"#索引和约束\" class=\"headerlink\" title=\"索引和约束\"></a>索引和约束</h3><h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><p>索引是一种以特定顺序保存的专用表。</p>\n<h5 id=\"创建索引\"><a href=\"#创建索引\" class=\"headerlink\" title=\"创建索引\"></a>创建索引</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table department </span><br><span class=\"line\">add index dept_name_idx (name);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看索引<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show index from department \\G</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>创建表时的包含一个约束，该约束将primary key dept_id列作为主关键字。</p>\n<ul>\n<li><p>删除索引</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table department </span><br><span class=\"line\">drop index dept_name_idx;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>唯一索引</strong></p>\n</li>\n</ul>\n<p>设计数据库时，需要考虑哪些列能包含重复数据，哪些列不能。<br>例如department表中不能出现两个相同名字的部门。可以通过department.name创建唯一索引限制出现重复部门名字。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table department </span><br><span class=\"line\">add unique dept_name_idx (name);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>多列索引</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table employee </span><br><span class=\"line\">add index emp_names_idx (lname, fname);</span><br></pre></td></tr></table></figure>\n<p>创建多列索引时，必须考虑哪一列作为第一列，哪一列作为第二列，这样索引才会尽可能的有用。</p>\n<h5 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h5><ul>\n<li><strong>B树索引</strong></li>\n</ul>\n<p>平衡树索引</p>\n<p>MySQL、Oracle、SQL Server默认都是B树索引。</p>\n<p>当向表中插入、更新和删除行时，服务器会尽力保持树的平衡。</p>\n<ul>\n<li><strong>位图索引</strong></li>\n</ul>\n<p>位图索引通常应用于数据仓库环境，那里有大量数据被索引，那些列却只包含相对少的值（比如销售岗位、地理环境、产品、销售员）</p>\n<ul>\n<li><strong>文本索引</strong></li>\n</ul>\n<p>MySQL、SQL Server   全文索引<br>Oracle              Oracle Text</p>\n<h5 id=\"如何使用索引\"><a href=\"#如何使用索引\" class=\"headerlink\" title=\"如何使用索引\"></a>如何使用索引</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain select cust_id, sum(avail_balance) tot_bal </span><br><span class=\"line\">from account </span><br><span class=\"line\">where cust_id in (1,5,9,11) </span><br><span class=\"line\">group by cust_id \\G</span><br></pre></td></tr></table></figure>\n<p>结果：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">           id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: account</span><br><span class=\"line\">   partitions: NULL</span><br><span class=\"line\">         type: index</span><br><span class=\"line\">possible_keys: fk_a_cust_id</span><br><span class=\"line\">          key: fk_a_cust_id</span><br><span class=\"line\">      key_len: 4</span><br><span class=\"line\">          ref: NULL</span><br><span class=\"line\">         rows: 24</span><br><span class=\"line\">     filtered: 33.33</span><br><span class=\"line\">        Extra: Using where</span><br><span class=\"line\">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<p>优化，给cust_id和avail_balance两列添加新索引：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table account </span><br><span class=\"line\">add index acc_bal_idx (cust_id, avail_balance);</span><br></pre></td></tr></table></figure></p>\n<p>再次查询优化器是如何处理的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explain select cust_id, sum(avail_balance) tot_bal </span><br><span class=\"line\">from account </span><br><span class=\"line\">where cust_id in (1,5,9,11) </span><br><span class=\"line\">group by cust_id \\G</span><br></pre></td></tr></table></figure></p>\n<p>结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*************************** 1. row ***************************</span><br><span class=\"line\">           id: 1</span><br><span class=\"line\">  select_type: SIMPLE</span><br><span class=\"line\">        table: account</span><br><span class=\"line\">   partitions: NULL</span><br><span class=\"line\">         type: range</span><br><span class=\"line\">possible_keys: acc_bal_idx</span><br><span class=\"line\">          key: acc_bal_idx</span><br><span class=\"line\">      key_len: 4</span><br><span class=\"line\">          ref: NULL</span><br><span class=\"line\">         rows: 8</span><br><span class=\"line\">     filtered: 100.00</span><br><span class=\"line\">        Extra: Using where; Using index</span><br><span class=\"line\">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>==优化器使用了新索引，而不是fk_a_cust_id==</li>\n<li>==优化器预期只需要8行，而不是24行==</li>\n<li>==不需要account表即可满足查询结果（使用附加列的索引指定）==</li>\n</ul>\n<h5 id=\"索引的不足\"><a href=\"#索引的不足\" class=\"headerlink\" title=\"索引的不足\"></a>索引的不足</h5><ul>\n<li>每个索引其实 都是一个表</li>\n<li>每次在对表添加或删除行时，表中的所有索引必须被修改，当更新行时，受到影响的列的任何索引也必须被修改。</li>\n<li>索引越多，服务器就需要做越多的工作来保持所有模式对象最新。</li>\n</ul>\n<p>默认策略：</p>\n<ul>\n<li>==确保所有的主键列被索引==（大部分服务器会在创建主键约束时自动生成唯一索引），针对多列主键，考虑为主键列的子集构建附加索引，或者以与主键约束定义不同的顺序为所有主键列另外生成索引</li>\n<li>==为所有被外键约束引用的列创建索引。== 服务器在准备删除父行时会查找以确保没有子行存在，为此他必须发出一个查询搜索列中的特定值，如果该列没有索引，那么服务器必须扫描整个表</li>\n<li>==索引那些被频繁检索的列。除了短字符串（3～50个字符）列，大多数日期列也是不错的候选==</li>\n</ul>\n<h4 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h4><ul>\n<li>主键约束</li>\n<li>外键约束</li>\n<li>唯一约束</li>\n<li>检查约束</li>\n</ul>\n<p><strong>创建约束</strong><br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> product </span><br><span class=\"line\">(product_cd <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\"><span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">product_type_cd <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">date_offered <span class=\"built_in\">date</span>,</span><br><span class=\"line\">date_retired <span class=\"built_in\">date</span>,</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> fk_product_type_cd <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> (product_type_cd) </span><br><span class=\"line\"><span class=\"keyword\">references</span> product_type (product_type_cd) ,</span><br><span class=\"line\"><span class=\"keyword\">constraint</span> pk_product primary <span class=\"keyword\">key</span> (product_cd)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"约束与索引\"><a href=\"#约束与索引\" class=\"headerlink\" title=\"约束与索引\"></a>约束与索引</h5><p>MySQL 主键约束、外键约束和唯一约束时，都会生成索引。</p>\n<h5 id=\"级联约束\"><a href=\"#级联约束\" class=\"headerlink\" title=\"级联约束\"></a>级联约束</h5><ul>\n<li>on updae cascade</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> product </span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> fk_product_type_cd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> product </span><br><span class=\"line\"><span class=\"keyword\">add</span> <span class=\"keyword\">constraint</span> fk_product_type_cd <span class=\"keyword\">foreign</span> <span class=\"keyword\">key</span> (product_type_cd) </span><br><span class=\"line\"><span class=\"keyword\">references</span> product_type (product_type_cd) </span><br><span class=\"line\"><span class=\"keyword\">on</span> <span class=\"keyword\">update</span> <span class=\"keyword\">cascade</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>on delete cascade</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alter table product </span><br><span class=\"line\">add constraint fk_product_type_cd foreign key (product_type_cd) </span><br><span class=\"line\">references product_type (product_type_cd) </span><br><span class=\"line\">on update cascade </span><br><span class=\"line\">on delete cascade;</span><br></pre></td></tr></table></figure>\n<h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3><p>创建视图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view customer_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">fed_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">zipcode</span><br><span class=\"line\">)</span><br><span class=\"line\">as</span><br><span class=\"line\">select cust_id,</span><br><span class=\"line\">concat(&apos;ends in &apos;, substr(fed_id,8,4)) fed_id, </span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">postal_code</span><br><span class=\"line\">from customer;</span><br></pre></td></tr></table></figure></p>\n<p>使用视图<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id, fed_id, cust_type_cd </span><br><span class=\"line\">from customer_vw;</span><br></pre></td></tr></table></figure></p>\n<p>服务器真正执行的查询是将两者合并创建的一个新查询：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cust_id,</span><br><span class=\"line\">concat(&quot;ends in &quot;, substr(fed_id,8,4)) fed_id,</span><br><span class=\"line\">cust_type_cd </span><br><span class=\"line\">from customer;</span><br></pre></td></tr></table></figure></p>\n<p>查看视图有哪些列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">describe customer_vw;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select cst.cust_id, cst.fed_id, bus.name </span><br><span class=\"line\">from customer_vw cst inner join business bus </span><br><span class=\"line\">on cst.cust_id = bus.cust_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么使用视图\"><a href=\"#为什么使用视图\" class=\"headerlink\" title=\"为什么使用视图\"></a>为什么使用视图</h4><h5 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h5><p>只能查询企业用户：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view business_customer_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">fed_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">zipcode</span><br><span class=\"line\">) </span><br><span class=\"line\">as </span><br><span class=\"line\">select cust_id,</span><br><span class=\"line\">concat(&apos;ends in &apos;, substr(fed_id, 8, 4)) fed_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">address,</span><br><span class=\"line\">city,</span><br><span class=\"line\">state,</span><br><span class=\"line\">postal_code </span><br><span class=\"line\">from customer </span><br><span class=\"line\">where cust_type_cd = &apos;B&apos;;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"数据聚合\"><a href=\"#数据聚合\" class=\"headerlink\" title=\"数据聚合\"></a>数据聚合</h5><p>生成报表展示账户数据和每个客户的储蓄总额：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view customer_totals_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">cust_name,</span><br><span class=\"line\">num_accounts,</span><br><span class=\"line\">tot_deposits) </span><br><span class=\"line\">as </span><br><span class=\"line\">select cst.cust_id, cst.cust_type_cd,</span><br><span class=\"line\"> case </span><br><span class=\"line\">  when cst.cust_type_cd = &apos;B&apos; then </span><br><span class=\"line\">  (select bus.name from business bus where bus.cust_id = cst.cust_id) </span><br><span class=\"line\">  else </span><br><span class=\"line\">  (select concat(ind.fname, &apos; &apos;, ind.lname) </span><br><span class=\"line\">  from individual ind </span><br><span class=\"line\">  where ind.cust_id = cst.cust_id) </span><br><span class=\"line\"> end cust_name,</span><br><span class=\"line\"> sum(case when act.status = &apos;ACTIVE&apos; then 1 else 0 end) tot_active_accounts,</span><br><span class=\"line\"> sum(case when act.status = &apos;ACTIVE&apos; then act.avail_balance else 0 end) tot_balance </span><br><span class=\"line\">from customer cst inner join account act </span><br><span class=\"line\">on act.cust_id = cst.cust_id </span><br><span class=\"line\">group by cst.cust_id, cst.cust_type_cd;</span><br></pre></td></tr></table></figure></p>\n<p>决定将数据预聚合到一个表中而不是利用视图总计，那么可以先创建customer_totals表，然后修改视图customer_totals_vw定义，再从该表中检索数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create table customer_totals  </span><br><span class=\"line\">as </span><br><span class=\"line\">select * from customer_totals_vw;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create or replace view customer_totals_vw </span><br><span class=\"line\">(cust_id,</span><br><span class=\"line\">cust_type_cd,</span><br><span class=\"line\">cust_name,</span><br><span class=\"line\">num_accounts,</span><br><span class=\"line\">tot_deposits</span><br><span class=\"line\">) </span><br><span class=\"line\">as </span><br><span class=\"line\">select cust_id, cust_type_cd, cust_name, num_accounts, tot_deposits </span><br><span class=\"line\">from customer_totals;</span><br></pre></td></tr></table></figure>\n<h5 id=\"隐藏复杂性\"><a href=\"#隐藏复杂性\" class=\"headerlink\" title=\"隐藏复杂性\"></a>隐藏复杂性</h5><h5 id=\"连接分区数据\"><a href=\"#连接分区数据\" class=\"headerlink\" title=\"连接分区数据\"></a>连接分区数据</h5><p>transaction变的越来越大，那么设计者可以将其分为两个表：transaction_current,transaction_historic。然后可以通过视图将两个表联合起来：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">create view transaction_vw </span><br><span class=\"line\">(txn_date,</span><br><span class=\"line\">account_id,</span><br><span class=\"line\">txn_type_cd,</span><br><span class=\"line\">amount,</span><br><span class=\"line\">teller_emp_id,</span><br><span class=\"line\">execution_branch_id,</span><br><span class=\"line\">funds_avail_date</span><br><span class=\"line\">) </span><br><span class=\"line\">as </span><br><span class=\"line\">select txn_date, account_id, txn_type_cd, amount, teller_emp_id, </span><br><span class=\"line\">execution_branch_id, funds_avail_date </span><br><span class=\"line\">from transaction_historic </span><br><span class=\"line\">union all </span><br><span class=\"line\">select txn_date, account_id, txn_type_cd, amount, teller_emp_id, </span><br><span class=\"line\">execution_branch_id, funds_avail_date </span><br><span class=\"line\">from transaction_current;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"可更新的视图\"><a href=\"#可更新的视图\" class=\"headerlink\" title=\"可更新的视图\"></a>可更新的视图</h4><p>对于MySQL，如果以下条件能满足，那么视图就是可更新的：</p>\n<ul>\n<li>没有使用聚合函数，例如max()、min()、avg() 等</li>\n<li>视图没有使用group by或having子句</li>\n<li>select或from子句中不存在子查询，并且where子句中的任何子查询都不引用from子句中的表</li>\n<li>视图没有使用union、union all和distinct</li>\n<li>from子句包括不止一个表或可更新视图</li>\n<li>如果有不止一个表或视图，那么from子句只使用内连接</li>\n</ul>\n<p>修改视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update customer_vw </span><br><span class=\"line\">set city = &apos;Woooburn&apos; </span><br><span class=\"line\">where city =  &apos;Woburn&apos;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"元数据\"><a href=\"#元数据\" class=\"headerlink\" title=\"元数据\"></a>元数据</h3><ul>\n<li>元数据——数据的数据</li>\n<li>数据字典或者系统目录</li>\n</ul>\n<h4 id=\"信息模式\"><a href=\"#信息模式\" class=\"headerlink\" title=\"信息模式\"></a>信息模式</h4><ul>\n<li>==information_schema数据库==里所有可用对象是视图</li>\n</ul>\n<p>检索bank数据库里所有表的名字：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select table_name, table_type </span><br><span class=\"line\">from information_schema.tables </span><br><span class=\"line\">where table_schema = &apos;bank&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure></p>\n<p>在结果中排除视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select table_name, table_type </span><br><span class=\"line\">from information_schema.tables </span><br><span class=\"line\">where table_schema = &apos;bank&apos; and table_type = &apos;BASE TABLE&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure></p>\n<p>只检索视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select table_name,is_updatable </span><br><span class=\"line\">from information_schema.views </span><br><span class=\"line\">where table_schema=&apos;bank&apos; </span><br><span class=\"line\">order by 1;</span><br></pre></td></tr></table></figure></p>\n<p>查看表的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select column_name,data_type,character_maximum_length char_max_len,</span><br><span class=\"line\">numeric_precision num_prcsn, numeric_scale num_scale </span><br><span class=\"line\">from infromation_schema.columns </span><br><span class=\"line\">where table_schema=&apos;bank&apos; and table_name=&apos;account&apos; </span><br><span class=\"line\">order by ordinal_position;</span><br></pre></td></tr></table></figure></p>\n<p>查询表中的索引信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select index_name,non_unique,seq_in_index,column_name </span><br><span class=\"line\">from information_schema.statistics </span><br><span class=\"line\">where table_schema = &apos;bank&apos; and table_name = &apos;account&apos; </span><br><span class=\"line\">order by 1,3;</span><br></pre></td></tr></table></figure></p>\n<p>查询bank模式中的所有视图：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select constraint_name,table_name,constraint_type </span><br><span class=\"line\">from information_schema.table_constraints </span><br><span class=\"line\">where table_schema = &apos;bank&apos; </span><br><span class=\"line\">order by 3,1;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用元数据\"><a href=\"#使用元数据\" class=\"headerlink\" title=\"使用元数据\"></a>使用元数据</h4><h5 id=\"模式生成脚本\"><a href=\"#模式生成脚本\" class=\"headerlink\" title=\"模式生成脚本\"></a>模式生成脚本</h5><h5 id=\"生成动态SQL\"><a href=\"#生成动态SQL\" class=\"headerlink\" title=\"生成动态SQL\"></a>生成动态SQL</h5><p>MySQL为动态SQL执行提供了：</p>\n<ul>\n<li>prepare</li>\n<li>execute</li>\n<li>deallocate<br>语句</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--将sql语句赋给变量qry</span><br><span class=\"line\">set @qry = &apos;select cust_id, cust_type_cd, fed_id from customer&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">-- qry被prepare语句提交给数据库引擎（解析、安全检查、优化）</span><br><span class=\"line\">prepare dynsql1 from @qry;</span><br><span class=\"line\"></span><br><span class=\"line\">-- 执行</span><br><span class=\"line\">execute dynsql1;</span><br><span class=\"line\"></span><br><span class=\"line\">-- deallocate prepare关闭语句，释放执行中使用的所有数据库资源（如游标）</span><br><span class=\"line\">deallocate prepare dynsql1;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- 查询包含占位符</span><br><span class=\"line\">set @qry = &apos;select product_cd, name, product_type_cd, date_offered, date_retired from product where product_cd = ?&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">prepare dynsql2 from @qry;</span><br><span class=\"line\"></span><br><span class=\"line\">set @prodcd = &apos;CKH&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">execute dynsql2 using @prodcd;</span><br><span class=\"line\"></span><br><span class=\"line\">set @prodcd = &apos;SAV&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">execute dynsql2 usging @prodcd;</span><br><span class=\"line\"></span><br><span class=\"line\">deallocate prepare dynsql2;</span><br></pre></td></tr></table></figure>\n<p>可以通过使用元数据生成动态SQL查询语句，而不是使用上面的硬编码。</p>\n<h3 id=\"MySQL对SQL语言的扩展\"><a href=\"#MySQL对SQL语言的扩展\" class=\"headerlink\" title=\"MySQL对SQL语言的扩展\"></a>MySQL对SQL语言的扩展</h3><h4 id=\"limit子句\"><a href=\"#limit子句\" class=\"headerlink\" title=\"limit子句\"></a>limit子句</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">limit 3;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>组合limit子句和order by子句<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">order by how_many desc </span><br><span class=\"line\">limit 3;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">order by how_many desc </span><br><span class=\"line\">limit 2,1;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select open_emp_id, count(*) how_many </span><br><span class=\"line\">from account </span><br><span class=\"line\">group by open_emp_id </span><br><span class=\"line\">order by how_many desc </span><br><span class=\"line\">limit 2,999999999;</span><br></pre></td></tr></table></figure>\n<h5 id=\"into-outfile子句\"><a href=\"#into-outfile子句\" class=\"headerlink\" title=\"into outfile子句\"></a>into outfile子句</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, start_date </span><br><span class=\"line\">into outfile &apos;C:\\\\TEMP||emp_list.txt&apos; </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n<p>默认列间用制表符（’\\t’）隔开，记录间用换行符（’\\n’）隔开。</p>\n<ul>\n<li>改成用字符 ‘|’隔开<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select emp_id, fname, lname, start_date </span><br><span class=\"line\">into outfile &apos;C:\\\\TEMP||emp_list.txt&apos; </span><br><span class=\"line\">fields terminated by &apos;|&apos; </span><br><span class=\"line\">lines terminated by &apos;@&apos; </span><br><span class=\"line\">from employee;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"组合insert-update语句\"><a href=\"#组合insert-update语句\" class=\"headerlink\" title=\"组合insert/update语句\"></a>组合insert/update语句</h5><p>更新插入（upsert）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insert into branch_usage (branch_id, cust_id, last_visited_on) </span><br><span class=\"line\">values (1,5, current_timestamp()) </span><br><span class=\"line\">on duplicate key update last_visited_on = current_timestamp();</span><br></pre></td></tr></table></figure>\n<h5 id=\"多表更新与删除\"><a href=\"#多表更新与删除\" class=\"headerlink\" title=\"多表更新与删除\"></a>多表更新与删除</h5><p>同时删除account、customer、individual表中的某一个客户数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete account2, customer2, individual2 </span><br><span class=\"line\">from account2 inner join customer2 </span><br><span class=\"line\">on account2.cust_id=customer2.cust_id </span><br><span class=\"line\">inner join individual2 </span><br><span class=\"line\">on customer2.cust_id = individual2.cust_id </span><br><span class=\"line\">where individual2.cust_id = 1;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjzp88m9z00007n8u3wy75q8i","tag_id":"cjzp88ma700027n8u6erw3e03","_id":"cjzp88mad00077n8ugm3618j8"},{"post_id":"cjzp88mab00047n8uluah6ijq","tag_id":"cjzp88mad00067n8ueaasl3hy","_id":"cjzp88mah000a7n8udn8orsrr"},{"post_id":"cjzp88mac00057n8u3yglncsk","tag_id":"cjzp88mad00067n8ueaasl3hy","_id":"cjzp88mah000c7n8uyn4rb3vl"},{"post_id":"cjzp88mae00087n8ug1l6nh8h","tag_id":"cjzp88mah000b7n8u4af8fume","_id":"cjzp88mai000e7n8u5y2plkpc"},{"post_id":"cjzp88mae00087n8ug1l6nh8h","tag_id":"cjzp88mai000d7n8ut0efft3z","_id":"cjzp88mai000f7n8unye56yyv"},{"post_id":"cjzp88may000g7n8ubuttfc38","tag_id":"cjzp88maz000h7n8u57r3glmp","_id":"cjzp88maz000i7n8ua0s0naf1"}],"Tag":[{"name":"计划","_id":"cjzp88ma700027n8u6erw3e03"},{"name":"工具","_id":"cjzp88mad00067n8ueaasl3hy"},{"name":"leetcode","_id":"cjzp88mah000b7n8u4af8fume"},{"name":"算法","_id":"cjzp88mai000d7n8ut0efft3z"},{"name":"SQL","_id":"cjzp88maz000h7n8u57r3glmp"}]}}